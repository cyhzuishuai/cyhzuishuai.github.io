<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/"/>
      <url>/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/</url>
      
        <content type="html"><![CDATA[<p>title: solidity基础4-6<br>tags: [solidity基础]<br>categories: [solidity]<br>date: 2023-8-25 18:03:07</p><h1 id="Solidity极简入门-4-函数输出-return"><a href="#Solidity极简入门-4-函数输出-return" class="headerlink" title="Solidity极简入门: 4. 函数输出 return"></a>Solidity极简入门: 4. 函数输出 return</h1><p>这一讲，我们将介绍<code>Solidity</code>函数输出，包括：返回多种变量，命名式返回，以及利用解构式赋值读取全部和部分返回值。</p><h2 id="返回值-return和returns"><a href="#返回值-return和returns" class="headerlink" title="返回值 return和returns"></a>返回值 return和returns</h2><p><code>Solidity</code>有两个关键字与函数输出相关：<code>return</code>和<code>returns</code>，他们的区别在于：</p><ul><li><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</li><li><code>return</code>用于函数主体中，返回指定的变量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回多个变量</span><br><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;</span><br><span class="line">        return(1, true, [uint256(1),2,5]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们声明了<code>returnMultiple()</code>函数将有多个输出：<code>returns(uint256, bool, uint256[3] memory)</code>，接着我们在函数主体中用<code>return(1, true, [uint256(1),2,5])</code>确定了返回值。</p><h2 id="命名式返回"><a href="#命名式返回" class="headerlink" title="命名式返回"></a>命名式返回</h2><p>我们可以在<code>returns</code>中标明返回变量的名称，这样<code>solidity</code>会自动给这些变量初始化，并且自动返回这些函数的值，不需要加<code>return</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;</span><br><span class="line">    _number = 2;</span><br><span class="line">    _bool = false; </span><br><span class="line">    _array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们用<code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code>声明了返回变量类型以及变量名。这样，我们在主体中只需要给变量<code>_number</code>，<code>_bool</code>和<code>_array</code>赋值就可以自动返回了。</p><p>当然，你也可以在命名式返回中用<code>return</code>来返回变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命名式返回，依然支持return</span><br><span class="line">function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;</span><br><span class="line">    return(1, true, [uint256(1),2,5]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p><code>solidity</code>使用解构式赋值的规则，支持读取函数的全部或部分返回值。</p><ul><li>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint256 _number;</span><br><span class="line">bool _bool;</span><br><span class="line">uint256[3] memory _array;</span><br><span class="line">(_number, _bool, _array) = returnNamed();</span><br></pre></td></tr></table></figure><ul><li>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(, _bool2, ) = returnNamed();</span><br></pre></td></tr></table></figure><p><strong>使用场景和好处</strong></p><ul><li><strong>代码简洁</strong>：使用结构式赋值可以使代码更加简洁易读，特别是在处理多个返回值或复杂数据结构时。</li><li><strong>减少错误</strong>：减少了额外的赋值语句，降低了因错误处理不当导致的bug。</li><li><strong>提高开发效率</strong>：直接在一行代码中完成多个变量的赋值，提高了开发效率。</li><li><strong>便于维护</strong>：代码更加简洁明了，便于后期维护和理解。</li></ul><p>结构式赋值是现代编程语言中的一个非常有用的特性，它能够让数据操作更加直观和高效。</p><h2 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ul><li>部署合约后查看三种返回方式的结果</li></ul><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/4-1-3c115fdc5afcb11e3f9eb51b8e2abbd8.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍函数的返回值<code>return</code>和<code>returns</code>，包括：返回多种变量，命名式返回，以及利用解构式赋值读取全部和部分返回值。</p><h1 id="Solidity极简入门-5-变量数据存储和作用域-storage-memory-calldata"><a href="#Solidity极简入门-5-变量数据存储和作用域-storage-memory-calldata" class="headerlink" title="Solidity极简入门: 5. 变量数据存储和作用域 storage&#x2F;memory&#x2F;calldata"></a>Solidity极简入门: 5. 变量数据存储和作用域 storage&#x2F;memory&#x2F;calldata</h1><h2 id="Solidity中的引用类型"><a href="#Solidity中的引用类型" class="headerlink" title="Solidity中的引用类型"></a>Solidity中的引用类型</h2><p>**引用类型(Reference Type)**：包括数组（<code>array</code>），结构体（<code>struct</code>）和映射（<code>mapping</code>），这类变量占空间大，赋值时候直接传递地址（类似指针）。&#x3D;&#x3D;由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。&#x3D;&#x3D;</p><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>solidity数据存储位置有三类：<code>storage</code>，<code>memory</code>和<code>calldata</code>。不同存储位置的<code>gas</code>成本不同。<code>storage</code>类型的数据存在链上，类似计算机的硬盘，消耗<code>gas</code>多；<code>memory</code>和<code>calldata</code>类型的临时存在内存里，消耗<code>gas</code>少。大致用法：</p><ol><li><code>storage</code>：合约里的&#x3D;&#x3D;状态变量默认都是<code>storage</code>&#x3D;&#x3D;，存储在链上。</li><li><code>memory</code>：函数里的参数和临时变量一般用<code>memory</code>，存储在内存中，不上链。</li><li><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量不能修改（<code>immutable</code>），一般用于函数的参数。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123;</span><br><span class="line">    //参数为calldata数组，不能被修改</span><br><span class="line">    // _x[0] = 0 //这样修改会报错</span><br><span class="line">    return(_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/5-1-9d00a21842c77b3911aaf419f67ad691.png" alt="5-1.png"></p><h3 id="数据位置和赋值规则"><a href="#数据位置和赋值规则" class="headerlink" title="数据位置和赋值规则"></a>数据位置和赋值规则</h3><p>&#x3D;&#x3D;在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。&#x3D;&#x3D;规则如下：</p><ol><li><code>storage</code>（合约的状态变量）赋值给&#x3D;&#x3D;本地（指的基本都是函数里面）&#x3D;&#x3D;<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint[] x = [1,2,3]; // 状态变量：数组 x</span><br><span class="line"></span><br><span class="line">function fStorage() public&#123;</span><br><span class="line">    //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x</span><br><span class="line">    uint[] storage xStorage = x;</span><br><span class="line">    xStorage[0] = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/5-2-91bae5b0b86b0e55210cac541a6edee5.png" alt="5-2.png"></p><ol><li><code>storage</code>赋值给<code>memory</code>，会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint[] x = [1,2,3]; // 状态变量：数组 x</span><br><span class="line"></span><br><span class="line">function fMemory() public view&#123;</span><br><span class="line">    //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x</span><br><span class="line">    uint[] memory xMemory = x;</span><br><span class="line">    xMemory[0] = 100;</span><br><span class="line">    xMemory[1] = 200;</span><br><span class="line">    uint[] memory xMemory2 = x;</span><br><span class="line">    xMemory2[0] = 300;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/5-3-979f3cbffbbe20ff5df5c143384610e4.png" alt="5-3.png"></p><ol><li><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</li><li>其他情况，变量赋值给<code>storage</code>，会创建独立的副本，修改其中一个不会影响另一个。</li></ol><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Variables &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    uint public y;</span><br><span class="line">    string public z;</span><br></pre></td></tr></table></figure><p>我们可以在函数里更改状态变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() external&#123;</span><br><span class="line">    // 可以在函数里更改状态变量的值</span><br><span class="line">    x = 5;</span><br><span class="line">    y = 2;</span><br><span class="line">    z = &quot;0xAA&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bar() external pure returns(uint)&#123;</span><br><span class="line">    uint xx = 1;</span><br><span class="line">    uint yy = 3;</span><br><span class="line">    uint zz = xx + yy;</span><br><span class="line">    return(zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function global() external view returns(address, uint, bytes memory)&#123;</span><br><span class="line">    address sender = msg.sender;</span><br><span class="line">    uint blockNum = block.number;</span><br><span class="line">    bytes memory data = msg.data;</span><br><span class="line">    return(sender, blockNum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子里，我们使用了3个常用的全局变量：<code>msg.sender</code>, <code>block.number</code>和<code>msg.data</code>，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p><ul><li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</li><li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li><li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li><li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li><li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li><li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li><li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li><li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li><li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li><li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的<code>wei</code>值</li></ul><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/5-4-5ee425310e1666a20575f2a8330c55cb.png" alt="5-4.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了<code>solidity</code>中的引用类型，数据位置和变量的作用域。重点是<code>storage</code>, <code>memory</code>和<code>calldata</code>三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低<code>gas</code>。下一讲我们会介绍引用类型中的数组。&#x3D;&#x3D;只用记住：合约中状态变量storage赋值给本地storage是引用，合约中memory赋值给本地变量memory也是引用，其他都是创建副本，改变一个其中另一个不会改变&#x3D;&#x3D;</p><h1 id="Solidity极简入门-6-引用类型-array-struct"><a href="#Solidity极简入门-6-引用类型-array-struct" class="headerlink" title="Solidity极简入门: 6. 引用类型, array, struct"></a>Solidity极简入门: 6. 引用类型, array, struct</h1><p>这一讲，我们将介绍<code>solidity</code>中的两个重要变量类型：数组（<code>array</code>）和结构体（<code>struct</code>）。</p><h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h2><p>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p><ul><li>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度 Array    uint[8] array1;    bytes1[5] array2;    address[100] array3;固定长度 Array</span><br><span class="line">uint[8] 数组1;</span><br><span class="line">字节1[5] 数组2;</span><br><span class="line">地址[100] 数组3;</span><br></pre></td></tr></table></figure><ul><li>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可变长度 Array</span><br><span class="line">uint[] array4;</span><br><span class="line">bytes1[] array5;</span><br><span class="line">address[] array6;</span><br><span class="line">bytes array7;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>。另外，不能用<code>byte[]</code>声明单字节数组，可以使用<code>bytes</code>或<code>bytes1[]</code>。在gas上，<code>bytes</code>比<code>bytes1[]</code>便宜。因为<code>bytes1[]</code>在<code>memory</code>中要增加31个字节进行填充，会产生额外的gas。但是在<code>storage</code>中，由于内存紧密打包，不存在字节填充。</p><h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p>在solidity里，创建数组有一些规则：</p><ul><li>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure><ul><li>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而<code>[uint(1),2,3]</code>里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。 下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] memory) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果创建的是动态数组，你需要一个一个元素的赋值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory x = new uint[](3);</span><br><span class="line">x[0] = 1;</span><br><span class="line">x[1] = 3;</span><br><span class="line">x[2] = 4;</span><br></pre></td></tr></table></figure><h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul><li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li><li><code>push()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素。</li><li><code>push(x)</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li><li><code>pop()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li></ul><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/6-1-ff58f00a7e037fcd318401ca2bc350b6.png" alt="6-1.png"></p><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。创建结构体的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    uint256 score; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student; // 初始一个student结构体</span><br></pre></td></tr></table></figure><p>给结构体赋值的两种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  给结构体赋值</span><br><span class="line">// 方法1:在函数中创建一个storage的struct引用</span><br><span class="line">function initStudent1() external&#123;</span><br><span class="line">    Student storage _student = student; // assign a copy of student</span><br><span class="line">    _student.id = 11;</span><br><span class="line">    _student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/6-2-991e08767256fcc39717f429da21f05d.png" alt="6-2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 方法2:直接引用状态变量的struct</span><br><span class="line">function initStudent2() external&#123;</span><br><span class="line">    student.id = 1;</span><br><span class="line">    student.score = 80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2024/04/21/solidity%E5%9F%BA%E7%A1%804-6/6-3-7ccb3cbebd7eff492292a171a8de1852.png" alt="6-3.png"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了solidity中数组（<code>array</code>）和结构体（<code>struct</code>）的基本用法。下一讲我们将介绍solidity中的哈希表——映射（<code>mapping</code>）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/13/hello-world/"/>
      <url>/2024/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础1-3</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Solidity-简介"><a href="#Solidity-简介" class="headerlink" title="Solidity 简介"></a>Solidity 简介</h2><p><code>Solidity</code> 是一种用于编写以太坊虚拟机（<code>EVM</code>）智能合约的编程语言。我认为掌握 <code>Solidity</code> 是参与链上项目的必备技能：区块链项目大部分是开源的，如果你能读懂代码，就可以规避很多亏钱项目。</p><p><code>Solidity</code> 具有两个特点：</p><ol><li>“基于对象”：学会 <code>Solidity</code> 之后，可以助你在区块链领域找到好工作，挣钱找对象。</li><li>“高级”：不会 <code>Solidity</code>，在币圈会显得很 low。</li></ol><h2 id="开发工具：Remix"><a href="#开发工具：Remix" class="headerlink" title="开发工具：Remix"></a>开发工具：Remix</h2><p>本教程中，我们将使用 <code>Remix</code> 运行 <code>Solidity</code> 合约。<code>Remix</code> 是以太坊官方推荐的智能合约集成开发环境（IDE），适合新手，可以在浏览器中快速开发和部署合约，无需在本地安装任何程序。</p><p>网址：<a href="https://remix.ethereum.org/">https://remix.ethereum.org</a></p><p>在 <code>Remix</code> 中，左侧菜单有三个按钮，分别对应文件（编写代码）、编译（运行代码）和部署（将合约部署到链上）。点击“创建新文件”（<code>Create New File</code>）按钮，即可创建一个空白的 <code>Solidity</code> 合约。</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-1.png" alt="Remix 面板"></p><h2 id="第一个-Solidity-程序"><a href="#第一个-Solidity-程序" class="headerlink" title="第一个 Solidity 程序"></a>第一个 Solidity 程序</h2><p>这个简单的程序只有 1 行注释和 3 行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract HelloWeb3&#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拆解程序，学习 Solidity 代码源文件的结构：</p><ol><li><p>第 1 行是注释，说明代码所使用的软件许可（license），这里使用的是 MIT 许可。如果不写许可，编译时会出现警告（warning），但程序仍可运行。Solidity 注释以“&#x2F;&#x2F;”开头，后面跟注释内容，注释不会被程序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br></pre></td></tr></table></figure></li><li><p>第 2 行声明源文件所使用的 Solidity 版本，因为不同版本的语法有差异。这行代码表示源文件将不允许小于 0.8.21 版本或大于等于 0.9.0 的编译器编译（第二个条件由 <code>^</code> 提供）。Solidity 语句以分号（;）结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.21;</span><br></pre></td></tr></table></figure></li><li><p>第 3-4 行是合约部分。第 3 行创建合约（contract），并声明合约名为 <code>HelloWeb3</code>。第 4 行是合约内容，声明了一个 string（字符串）变量 <code>_string</code>，并赋值为 “Hello Web3!”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWeb3 &#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>后续我们会更详细地介绍 Solidity 中的变量。</p><h2 id="编译并部署代码"><a href="#编译并部署代码" class="headerlink" title="编译并部署代码"></a>编译并部署代码</h2><p>在 Remix 编辑代码的页面，按 Ctrl + S 即可编译代码，非常方便。</p><p>编译完成后，点击左侧菜单的“部署”按钮，进入部署页面。</p><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-2.png" alt="Deploy配图"></p><p>默认情况下，<code>Remix</code> 会使用 <code>Remix</code> 虚拟机（以前称为 JavaScript 虚拟机）来模拟以太坊链，运行智能合约，类似在浏览器里运行一条测试链。<code>Remix</code> 还会为你分配一些测试账户，每个账户里有 100 ETH（测试代币），随意使用。点击 <code>Deploy</code>（黄色按钮），即可部署我们编写的合约。</p><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-3.png" alt="_string配图"></p><p>部署成功后，在下方会看到名为 <code>HelloWeb3</code> 的合约。点击 <code>_string</code>，即可看到 “Hello Web3!”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节课程中，我们简要介绍了 <code>Solidity</code> 和 <code>Remix</code> 工具，并完成了第一个 <code>Solidity</code> 程序 —— <code>HelloWeb3</code>。接下来，我们将继续深入学习 <code>Solidity</code>！</p><h3 id="中文-Solidity-资料推荐"><a href="#中文-Solidity-资料推荐" class="headerlink" title="中文 Solidity 资料推荐"></a>中文 Solidity 资料推荐</h3><ol><li><a href="https://docs.soliditylang.org/zh/v0.8.19/index.html">Solidity中文文档</a>（官方文档的中文翻译）</li><li><a href="https://space.bilibili.com/286084162">崔棉大师solidity教程</a> web3技术教学博主，我看他视频学到了很多</li></ol><h1 id="WTF-Solidity极简入门-2-值类型"><a href="#WTF-Solidity极简入门-2-值类型" class="headerlink" title="WTF Solidity极简入门: 2. 值类型"></a>WTF Solidity极简入门: 2. 值类型</h1><h2 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h2><p>&#x3D;&#x3D;主要就是这3种类型&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>引用类型(Reference Type)<strong>：包括</strong>数组</strong>和<strong>结构体</strong>，这类变量占空间大，赋值时候<strong>直接传递地址</strong>（类似指针）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>映射类型(Mapping Type)</strong>: Solidity中存储<strong>键值对</strong>的数据结构，可以理解为哈希表&#x3D;&#x3D;</li><li>函数类型(Function Types) : 代表函数的变量</li></ol><p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 布尔值</span><br><span class="line">bool public _bool = true;</span><br></pre></td></tr></table></figure><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 布尔运算</span><br><span class="line">bool public _bool1 = !_bool; // 取非</span><br><span class="line">bool public _bool2 = _bool &amp;&amp; _bool1; // 与</span><br><span class="line">bool public _bool3 = _bool || _bool1; // 或</span><br><span class="line">bool public _bool4 = _bool == _bool1; // 相等</span><br><span class="line">bool public _bool5 = _bool != _bool1; // 不相等</span><br></pre></td></tr></table></figure><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 整型</span><br><span class="line">int public _int = -1; // 整数，包括负数</span><br><span class="line">uint public _uint = 1; // 正整数</span><br><span class="line">uint256 public _number = 20220330; // 256位正整数</span><br></pre></td></tr></table></figure><p>常用的整型运算符包括：</p><ul><li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li><li>算数运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 整数运算</span><br><span class="line">uint256 public _number1 = _number + 1; // +，-，*，/</span><br><span class="line">uint256 public _number2 = 2**2; // 指数</span><br><span class="line">uint256 public _number3 = 7 % 2; // 取余数</span><br><span class="line">bool public _numberbool = _number2 &gt; _number3; // 比大小</span><br></pre></td></tr></table></figure><p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p><h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型(address)有两类：</p><ul><li>&#x3D;&#x3D;普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;payable address: 比普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员方法，用于接收转账。&#x3D;&#x3D;</li></ul><p>我们会在之后的章节更加详细地介绍 payable address。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 地址</span><br><span class="line">address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;</span><br><span class="line">address payable public _address1 = payable(_address); // payable address，可以转账、查余额</span><br><span class="line">// 地址类型的成员</span><br><span class="line">uint256 public balance = _address1.balance; // balance of address</span><br></pre></td></tr></table></figure><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>&#x3D;&#x3D;字节数组分为定长和不定长两种：&#x3D;&#x3D;</p><ul><li>&#x3D;&#x3D;定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组<strong>最多存储 32 bytes</strong> 数据，即<code>bytes32</code>。&#x3D;&#x3D;</li><li>不定长字节数组: 属于&#x3D;&#x3D;引用类型&#x3D;&#x3D;（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度的字节数组</span><br><span class="line">bytes32 public _byte32 = &quot;MiniSolidity&quot;; </span><br><span class="line">bytes1 public _byte = _byte32[0]; </span><br></pre></td></tr></table></figure><p>在上述代码中，<code>MiniSolidity</code> 变量以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p><p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p><p>&#x3D;&#x3D;表示一个16进制需要4位，一个bytes1是8位，所以一个bytes1可以表示2个16进制位&#x3D;&#x3D;</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用enum将uint 0， 1， 2表示为Buy, Hold, Sell</span><br><span class="line">enum ActionSet &#123; Buy, Hold, Sell &#125;</span><br><span class="line">// 创建enum变量 action</span><br><span class="line">ActionSet action = ActionSet.Buy;</span><br></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的正整数是否在枚举的长度内，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// enum可以和uint显式的转换</span><br><span class="line">function enumToUint() external view returns(uint)&#123;</span><br><span class="line">    return uint(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enum</code> 是一个比较冷门的变量，几乎没什么人用。</p><h2 id="在-Remix-上运行"><a href="#在-Remix-上运行" class="headerlink" title="在 Remix 上运行"></a>在 Remix 上运行</h2><ul><li>部署合约后可以查看每个类型的变量的数值：</li></ul><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/2-1.png" alt="2-1.png"></p><ul><li><code>enum</code> 和 <code>uint</code> 转换的示例：</li></ul><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/02_ValueTypes/img/2-2.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/2-2.png" alt="2-2.png"></a> </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 Solidity 中值类型，包括布尔型、整型、地址、定长字节数组和枚举。在后续章节，我们将继续介绍 Solidity 的其他变量类型，包括引用类型和映射类型。</p><h1 id="Solidity极简入门-3-函数类型"><a href="#Solidity极简入门-3-函数类型" class="headerlink" title="Solidity极简入门: 3. 函数类型"></a>Solidity极简入门: 3. 函数类型</h1><p>solidity官方文档里把函数归到数值类型，但我觉得差别很大，所以单独分一类。我们先看一下solidity中函数的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function &lt;function name&gt;(&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><p>Copy</p><p>看着些复杂，咱们从前往后一个一个看（方括号中的是可写可不写的关键字）：</p><ol><li><p><code>function</code>：声明函数时的固定用法，想写函数，就要以function关键字开头。</p></li><li><p><code>&lt;function name&gt;</code>：函数名。</p></li><li><p><code>(&lt;parameter types&gt;)</code>：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。</p></li><li><p><code>&#123;internal|external|public|private&#125;</code>：&#x3D;&#x3D;函数可见性说明符&#x3D;&#x3D;，一共4种。没标明函数类型的，&#x3D;&#x3D;默认&#x3D;&#x3D;<code>public</code>。合约之外的函数，即”自由函数”，始终具有隐含<code>internal</code>可见性。</p><ul><li><code>public</code>: 内部外部均可见。</li><li><code>private</code>: 只能从本合约内部访问，继承的合约也不能用。</li><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 &#x3D;&#x3D;这里this后文有解释&#x3D;&#x3D;</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><p><strong>Note 1</strong>: 没有标明可见性类型的函数，默认为<code>public</code>。</p><p><strong>Note 2</strong>: <code>public|private|internal</code> 也可用于&#x3D;&#x3D;修饰状态变量&#x3D;&#x3D;。 &#x3D;&#x3D;<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。&#x3D;&#x3D;</p><p><strong>Note 3</strong>: 没有标明可见性类型的&#x3D;&#x3D;状态变量，默认为<code>internal</code>。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;注意这里状态变量和函数可见性的不一样，默认为只能从合约内部访问&#x3D;&#x3D;</p></li><li><p><code>[pure|view|payable]</code>：&#x3D;&#x3D;决定函数权限&#x2F;功能的关键字&#x3D;&#x3D;。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入<code>ETH</code>。<code>pure</code>和<code>view</code>的介绍见下一节。</p></li></ol><p>&#x3D;&#x3D;如果没有写这三个关键字就是可读可写&#x3D;&#x3D;</p><ol><li><code>[returns ()]</code>：函数返回的变量类型和名称。</li></ol><h2 id="到底什么是Pure和View"><a href="#到底什么是Pure和View" class="headerlink" title="到底什么是Pure和View"></a>到底什么是<code>Pure</code>和<code>View</code></h2><p>我刚开始学<code>solidity</code>的时候，一直不理解<code>pure</code>跟<code>view</code>关键字，因为别的语言没有类似的关键字。<code>solidity</code>加入这两个关键字，我认为是因为<code>gas fee</code>。合约的状态变量存储在链上，<code>gas fee</code>很贵，如果不改变链上状态，就不用付<code>gas</code>。包含<code>pure</code>跟<code>view</code>关键字的函数是&#x3D;&#x3D;<strong>不改写链上状态的</strong>&#x3D;&#x3D;，因此用户直接调用他们是不需要付gas的（合约中非<code>pure</code>&#x2F;<code>view</code>函数调用它们则会改写链上状态，需要付gas）。</p><p>&#x3D;&#x3D;这里可太重要了&#x3D;&#x3D;</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用<code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记<code>view</code>或<code>pure</code>的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><p>我画了一个马里奥插画，帮助大家理解。在插画里，我把合约中的状态变量（存储在链上）比作碧池公主，三种不同的角色代表不同的关键字。</p><p><a href="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538"><img src="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538" alt="WTF is pure and view in solidity?"></a></p><ul><li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数<strong>既不能读取也不能写入链上的状态变量</strong>。就像小怪一样，看不到也摸不到碧琪公主。</li><li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li><li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-pure-和-view"><a href="#1-pure-和-view" class="headerlink" title="1. pure 和 view"></a>1. pure 和 view</h3><p>我们在合约里定义一个状态变量 <code>number</code>，初始化为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract FunctionTypes&#123;</span><br><span class="line">    uint256 public number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>add()</code> 函数，每次调用会让 <code>number</code> 增加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 默认function</span><br><span class="line">function add() external&#123;</span><br><span class="line">    number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>add()</code> 函数被标记为 <code>pure</code>，比如 <code>function add() external pure</code>，就会报错。因为 <code>pure</code> 是不配读取合约里的状态变量的，更不配改写。那 <code>pure</code> 函数能做些什么？举个例子，你可以给函数传递一个参数 <code>_number</code>，然后让他返回 <code>_number + 1</code>，这个操作不会读取或写入状态变量。</p><p>&#x3D;&#x3D;我的理解就是，参数或者函数内部定义的变量都不是状态变量，函数结束了，这些变量就消失了，也不上链&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pure: 纯纯牛马</span><br><span class="line">function addPure(uint256 _number) external pure returns(uint256 new_number)&#123;</span><br><span class="line">    new_number = _number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-3.png" alt="3-3.png"></p><p>如果 <code>add()</code> 函数被标记为 <code>view</code>，比如 <code>function add() external view</code>，也会报错。因为 <code>view</code> 能读取，但不能够改写状态变量。我们可以稍微改写下函数，读取但是不改写 <code>number</code>，返回一个新的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// view: 看客</span><br><span class="line">function addView() external view returns(uint256 new_number) &#123;</span><br><span class="line">    new_number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-4.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-4.png" alt="3-4.png"></a></p><p>&#x3D;&#x3D;重点来了，view和pure的区别就是view可以读取状态变量，pure不可以读取状态变量，他的输出只能由参数决定。&#x3D;&#x3D;</p><h3 id="2-internal-v-s-external"><a href="#2-internal-v-s-external" class="headerlink" title="2. internal v.s. external"></a>2. internal v.s. external</h3><ul><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// internal: 内部函数</span><br><span class="line">function minus() internal &#123;</span><br><span class="line">    number = number - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约内的函数可以调用内部函数</span><br><span class="line">function minusCall() external &#123;</span><br><span class="line">    minus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;重点来了，也就是带有函数可见性说明符internal的，在部署完之后，不可以调用，因为我们部署完合约之后，在remix里面进行函数调用，查看变量，传参都相当于在合约外部调用，所以想要调用带有internal的函数，只能通过另外一个external函数调用&#x3D;&#x3D;</p><p>我们定义一个 <code>internal</code> 的 <code>minus()</code> 函数，每次调用使得 <code>number</code> 变量减少 1。由于 <code>internal</code> 函数只能由合约内部调用，我们必须再定义一个 <code>external</code> 的 <code>minusCall()</code> 函数，通过它间接调用内部的 <code>minus()</code> 函数。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-1.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-1.png" alt="3-1.png"></a></p><h3 id="3-payable"><a href="#3-payable" class="headerlink" title="3. payable"></a>3. payable</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// payable: 递钱，能给合约支付eth的函数</span><br><span class="line">function minusPayable() external payable returns(uint256 balance) &#123;</span><br><span class="line">    minus();    </span><br><span class="line">    balance = address(this).balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>external payable</code> 的 <code>minusPayable()</code> 函数，间接的调用 <code>minus()</code>，并且返回合约里的 ETH 余额（<code>this</code> 关键字可以让我们引用合约地址）。我们可以在调用 <code>minusPayable()</code> 时往合约里转入1个 ETH。</p><p>&#x3D;&#x3D;<code>this</code>关键字代表合约自身的地址。<code>address(this).balance</code>会返回当前合约地址所持有的以太币（ETH）数量，以wei为单位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>关键字代表当前合约的实例。它允许你在合约内部访问合约自身的成员，比如函数和状态变量。<code>this</code>可以在合约的任何函数内使用，但通常在需要引用合约自身的上下文中使用，比如转账操作时指向合约自己的地址（<code>address(this)</code>）。这使得合约能够操作自己的属性和调用自己的方法。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>除了用于引用合约自身的实例和获取合约的地址外（<code>address(this)</code>），还可以用来在合约内部调用当前合约的其他公共和外部函数。例如，如果你有一个公共函数<code>functionA</code>，你可以通过<code>this.functionA()</code>来调用它，尤其在需要显式地表明函数调用是在合约内部发生时。这种方式通常用于需要通过合约地址调用函数的场景，确保调用遵循EVM的调用规则，如通过消息调用（message call）。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;一言以蔽之：在合约内部使用<code>this</code>调用函数，实际上是模拟外部调用者的行为。&#x3D;&#x3D;</p><p><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    uint256 public myNumber;</span><br><span class="line"></span><br><span class="line">    function setMyNumber(uint256 _myNumber) external &#123;</span><br><span class="line">        myNumber = _myNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateMyNumber(uint256 _newNumber) public &#123;</span><br><span class="line">        // 使用this关键字调用当前合约的另一个函数(external) 必须使用this</span><br><span class="line">        this.setMyNumber(_newNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838"><img src="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838" alt="mirror-image-1"></a></p><p>我们可以在返回的信息中看到，合约的余额变为 1 ETH。</p><p><a href="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330"><img src="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330" alt="mirror-image-2"></a></p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-2.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-2.png" alt="3-2.png"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 <code>Solidity</code> 中的函数。<code>pure</code> 和 <code>view</code> 关键字比较难理解，在其他语言中没出现过：<code>view</code> 函数可以读取状态变量，但不能改写；<code>pure</code> 函数既不能读取也不能改写状态变量。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
