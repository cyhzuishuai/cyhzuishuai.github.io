<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>solidity基础10-12</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%8010-12/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%8010-12/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-10-控制流，用solidity实现插入排序"><a href="#Solidity极简入门-10-控制流，用solidity实现插入排序" class="headerlink" title="Solidity极简入门: 10. 控制流，用solidity实现插入排序"></a>Solidity极简入门: 10. 控制流，用solidity实现插入排序</h1><p>这一讲，我们将介绍<code>solidity</code>中的控制流，然后讲如何用<code>solidity</code>实现插入排序（<code>InsertionSort</code>），一个看起来简单，但实际上很容易写出<code>bug</code>的程序。</p><span id="more"></span><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><code>Solidity</code>的控制流与其他语言类似，主要包含以下几种：</p><ol><li><code>if-else</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function ifElseTest(uint256 _number) public pure returns(bool)&#123;</span><br><span class="line">    if(_number == 0)&#123;</span><br><span class="line">    return(true);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    return(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>for循环</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function forLoopTest() public pure returns(uint256)&#123;</span><br><span class="line">    uint sum = 0;</span><br><span class="line">    for(uint i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>while循环</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function whileTest() public pure returns(uint256)&#123;</span><br><span class="line">    uint sum = 0;</span><br><span class="line">    uint i = 0;</span><br><span class="line">    while(i &lt; 10)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>do-while循环</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doWhileTest() public pure returns(uint256)&#123;</span><br><span class="line">    uint sum = 0;</span><br><span class="line">    uint i = 0;</span><br><span class="line">    do&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">    &#125;while(i &lt; 10);</span><br><span class="line">    return(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>三元运算符</code> 三元运算符是<code>solidity</code>中唯一一个接受三个操作数的运算符，规则<code>条件? 条件为真的表达式:条件为假的表达式</code>。 此运算符经常用作 if 语句的快捷方式。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 三元运算符 ternary/conditional operator</span><br><span class="line">function ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123;</span><br><span class="line">    // return the max of x and y</span><br><span class="line">    return x &gt;= y ? x: y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有<code>continue</code>（立即进入下一个循环）和<code>break</code>（跳出当前循环）关键字可以使用。</p><h2 id="用solidity实现插入排序"><a href="#用solidity实现插入排序" class="headerlink" title="用solidity实现插入排序"></a>用<code>solidity</code>实现插入排序</h2><h3 id="写在前面：90-以上的人用solidity写插入算法都会出错。"><a href="#写在前面：90-以上的人用solidity写插入算法都会出错。" class="headerlink" title="写在前面：90%以上的人用solidity写插入算法都会出错。"></a>写在前面：90%以上的人用<code>solidity</code>写插入算法都会出错。</h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>排序算法解决的问题是将无序的一组数字，例如<code>[2, 5, 3, 1]</code>，从小到大依次排列好。插入排序（<code>InsertionSort</code>）是最简单的一种排序算法，也是很多人学习的第一个算法。它的思路很简单，从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。示意图：</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/92b034385c440e08bc8551c97df0a2e3.gif" alt="插入排序"></p><h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a><code>python</code>代码</h3><p>我们可以先看一下插入排序的python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python program for implementation of Insertion Sort</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;=<span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j] :</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="改写成solidity后有BUG！"><a href="#改写成solidity后有BUG！" class="headerlink" title="改写成solidity后有BUG！"></a>改写成<code>solidity</code>后有<code>BUG</code>！</h3><p>一共8行<code>python</code>代码就可以完成插入排序，非常简单。那么我们将它改写成<code>solidity</code>代码，将函数，变量，循环等等都做了相应的转换，只需要9行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序 错误版</span><br><span class="line">function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) &#123;</span><br><span class="line">    </span><br><span class="line">    for (uint i = 1;i &lt; a.length;i++)&#123;</span><br><span class="line">        uint temp = a[i];</span><br><span class="line">        uint j=i-1;</span><br><span class="line">        while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j]))&#123;</span><br><span class="line">            a[j+1] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们把改好的放到<code>remix</code>上去跑，输入<code>[2, 5, 3, 1]</code>。BOOM！有<code>bug</code>！改了半天，没找到<code>bug</code>在哪。我又去<code>google</code>搜”solidity insertion sort”，然后发现网上用<code>solidity</code>写的插入算法教程都是错的，比如：<a href="https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d">Sorting in Solidity without Comparison</a></p><p>Remix decoded output 出现错误内容</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/10-1-e9590da7aad6c176501b7fc5abe3372f.jpg" alt="10-1"></p><h3 id="正确的solidity插入排序"><a href="#正确的solidity插入排序" class="headerlink" title="正确的solidity插入排序"></a>正确的solidity插入排序</h3><p>花了几个小时，在<code>Dapp-Learning</code>社群一个朋友的帮助下，终于找到了<code>bug</code>所在。<code>solidity</code>中最常用的变量类型是<code>uint</code>，也就是正整数，取到负值的话，会报<code>underflow</code>错误。而在插入算法中，变量<code>j</code>有可能会取到<code>-1</code>，引起报错。</p><p>这里，我们需要把<code>j</code>加1，让它无法取到负值。正确代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序 正确版</span><br><span class="line">function insertionSort(uint[] memory a) public pure returns(uint[] memory) &#123;</span><br><span class="line">    // note that uint can not take negative value</span><br><span class="line">    for (uint i = 1;i &lt; a.length;i++)&#123;</span><br><span class="line">        uint temp = a[i];</span><br><span class="line">        uint j=i;</span><br><span class="line">        while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1]))&#123;</span><br><span class="line">            a[j] = a[j-1];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的结果：</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/S-i6rwCMeXoi8eNJ0fRdB.png" alt="&quot;输入[2,5,3,1] 输出[1,2,3,5] &quot;"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>中控制流，并且用<code>solidity</code>写了插入排序。看起来很简单，但实际很难。这就是<code>solidity</code>，坑很多，每个月都有项目因为这些小<code>bug</code>损失几千万甚至上亿美元。掌握好基础，不断练习，才能写出更好的<code>solidity</code>代码。</p><h1 id="Solidity极简入门-11-构造函数和修饰器"><a href="#Solidity极简入门-11-构造函数和修饰器" class="headerlink" title="Solidity极简入门: 11. 构造函数和修饰器"></a>Solidity极简入门: 11. 构造函数和修饰器</h1><p>这一讲，我们将用合约权限控制（<code>Ownable</code>）的例子介绍<code>solidity</code>语言中构造函数（<code>constructor</code>）和独有的修饰器（<code>modifier</code>）。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的<code>owner</code>地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address owner; // 定义owner变量</span><br><span class="line"></span><br><span class="line">// 构造函数</span><br><span class="line">constructor() &#123;</span><br><span class="line">   owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>⚠️：构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 <code>constructor</code> 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 <code>Parents</code>，构造函数名写成 <code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 <code>constructor</code> 写法。</p><p>构造函数的旧写法代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =0.4.21;</span><br><span class="line">contract Parents &#123;</span><br><span class="line">    // 与合约名Parents同名的函数就是构造函数</span><br><span class="line">    function Parents () public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。<code>modifier</code>的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/nVwXsOVmrYu8rqvKKPMpg.jpg" alt="钢铁侠的modifier"></p><p>我们来定义一个叫做onlyOwner的modifier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义modifier</span><br><span class="line">modifier onlyOwner &#123;</span><br><span class="line">   require(msg.sender == owner); // 检查调用者是否为owner地址</span><br><span class="line">   _; // 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有<code>onlyOwner</code>修饰符的函数只能被<code>owner</code>地址调用，比如下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function changeOwner(address _newOwner) external onlyOwner&#123;</span><br><span class="line">   owner = _newOwner; // 只有owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>changeOwner</code>函数，运行他可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p><h3 id="OppenZepplin的Ownable标准实现："><a href="#OppenZepplin的Ownable标准实现：" class="headerlink" title="OppenZepplin的Ownable标准实现："></a>OppenZepplin的Ownable标准实现：</h3><p><code>OppenZepplin</code>是一个维护<code>solidity</code>标准化代码库的组织，他的<code>Ownable</code>标准实现如下： <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol</a></p><h2 id="Remix-演示示例"><a href="#Remix-演示示例" class="headerlink" title="Remix 演示示例"></a>Remix 演示示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor ()&#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner&#123;</span><br><span class="line">        require(owner==msg.sender);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeOwner(address _newOwner) external onlyOwner&#123;</span><br><span class="line">        owner = _newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <code>Owner.sol</code> 为例。</p><ol><li><p>在 Remix 上编译部署代码。</p></li><li><p>点击owner</p><p>按钮查看当前 owner 变量。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/11-1-158ba3a195f7ecc313538aae20c45658.jpg" alt="img"></p></li><li><p>以 owner 地址的用户身份，调用changeOwner函数，交易成功。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/11-2-4127c92edede8fbe048358b699b57589.jpg" alt="img"></p></li><li><p>以非 owner 地址的用户身份，调用changeOwner函数，交易失败，因为modifier onlyOwner 的检查语句不满足。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/11-3-c6c793034d8354ecf203513b644321df.jpg" alt="img"></p></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>中的构造函数和修饰符，并举了一个控制合约权限的<code>Ownable</code>合约。</p><h1 id="Solidity极简入门-12-事件"><a href="#Solidity极简入门-12-事件" class="headerlink" title="Solidity极简入门: 12. 事件"></a>Solidity极简入门: 12. 事件</h1><p>这一讲，我们用转账ERC20代币为例来介绍<code>solidity</code>中的事件（<code>event</code>）。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><code>Solidity</code>中的事件（<code>event</code>）是<code>EVM</code>上日志的抽象，它具有两个特点：</p><ul><li>响应：应用程序（<a href="https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18"><code>ethers.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</li><li>经济：事件是<code>EVM</code>上比较经济的存储数据的方式，每个大概消耗2,000 <code>gas</code>；相比之下，链上存储一个新变量至少需要20,000 <code>gas</code>。</li></ul><h3 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h3><p>事件的声明由<code>event</code>关键字开头，接着是事件名称，括号里面写好事件需要记录的变量类型和变量名。以<code>ERC20</code>代币合约的<code>Transfer</code>事件为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>Transfer</code>事件共记录了3个变量<code>from</code>，<code>to</code>和<code>value</code>，分别对应代币的转账地址，接收地址和转账数量，其中<code>from</code>和<code>to</code>前面带有<code>indexed</code>关键字，他们会保存在以太坊虚拟机日志的<code>topics</code>中，方便之后检索。</p><p>&#x3D;&#x3D;在Solidity中，<code>indexed</code> 关键字用于声明事件的参数，允许这些参数在区块链的日志中被索引，这有助于外部的监听器高效地筛选这些事件。然而，并非所有类型的变量都可以使用<code>indexed</code>修饰。<code>indexed</code>关键字只能用于数据类型为<code>address</code>、<code>uint</code>、<code>int</code>、<code>bool</code>以及固定长度的<code>bytes</code>类型。对于更复杂的数据类型，如字符串（<code>string</code>）和动态数组（如<code>bytes</code>），不可以使用<code>indexed</code>修饰，因为这些类型的数据通常需要更多的存储空间，而且它们的日志存储方式与简单类型不同。&#x3D;&#x3D;</p><h3 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h3><p>我们可以在函数里释放事件。在下面的例子中，每次用<code>_transfer()</code>函数进行转账操作的时候，都会释放<code>Transfer</code>事件，并记录相应的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义_transfer函数，执行转账逻辑</span><br><span class="line">function _transfer(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external &#123;</span><br><span class="line"></span><br><span class="line">    _balances[from] = 10000000; // 给转账地址一些初始代币</span><br><span class="line"></span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line"></span><br><span class="line">    // 释放事件</span><br><span class="line">    emit Transfer(from, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EVM日志-Log"><a href="#EVM日志-Log" class="headerlink" title="EVM日志 Log"></a>EVM日志 <code>Log</code></h2><p>以太坊虚拟机（EVM）用日志<code>Log</code>来存储<code>Solidity</code>事件，每条日志记录都包含主题<code>topics</code>和数据<code>data</code>两部分。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/12-3-06b5d454b3752b96000f8a9477fa31de.png" alt="img"></p><h3 id="主题-Topics"><a href="#主题-Topics" class="headerlink" title="主题 Topics"></a>主题 <code>Topics</code></h3><p>日志的第一部分是主题数组，用于描述事件，长度不能超过<code>4</code>。它的第一个元素是事件的签名（哈希）。对于上面的<code>Transfer</code>事件，它的签名就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;Transfer(addrses,address,uint256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;产生事件的哈希和这个合约的发起者不是一个东西&#x3D;&#x3D;</p><p>除了事件签名，主题还可以包含至多<code>3</code>个<code>indexed</code>参数，也就是<code>Transfer</code>事件中的<code>from</code>和<code>to</code>。</p><p><code>indexed</code>标记的参数可以理解为检索事件的索引“键”，方便之后搜索。每个 <code>indexed</code> 参数的大小为固定的256比特，如果参数太大了（比如字符串），就会自动计算哈希存储在主题中。</p><h3 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 Data"></a>数据 <code>Data</code></h3><p>事件中不带 <code>indexed</code>的参数会被存储在 <code>data</code> 部分中，可以理解为事件的“值”。<code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topic</code> 部分中，也是以哈希的方式存储。另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topic</code> 更少。</p><h2 id="Remix演示"><a href="#Remix演示" class="headerlink" title="Remix演示"></a><code>Remix</code>演示</h2><p>以 <code>Event.sol</code> 合约为例，编译部署。</p><p>然后调用 <code>_transfer</code> 函数。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/12-1-21d3090d03ff4dbb241e5810f2177fe8.jpg" alt="img"></p><p>点击右侧的交易查看详情，可以看到日志的具体内容。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/12-2-4faa09c9994dc41555b86c1f023b4c38.jpg" alt="img"></p><h3 id="在etherscan上查询事件"><a href="#在etherscan上查询事件" class="headerlink" title="在etherscan上查询事件"></a>在etherscan上查询事件</h3><p>我们尝试用<code>_transfer()</code>函数在<code>Rinkeby</code>测试网络上转账100代币，可以在<code>etherscan</code>上查询到相应的<code>tx</code>：<a href="https://rinkeby.etherscan.io/tx/0x8cf87215b23055896d93004112bbd8ab754f081b4491cb48c37592ca8f8a36c7">网址</a>。</p><p>点击<code>Logs</code>按钮，就能看到事件明细：</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8010-12/gx6_wDMYEl8_Gc_JkTIKn.png" alt="Event明细"></p><p><code>Topics</code>里面有三个元素，<code>[0]</code>是这个事件的哈希，<code>[1]</code>和<code>[2]</code>是我们定义的两个<code>indexed</code>变量的信息，即转账的转出地址和接收地址。<code>Data</code>里面是剩下的不带<code>indexed</code>的变量，也就是转账数量。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了如何使用和查询<code>solidity</code>中的事件。很多链上分析工具包括<code>Nansen</code>和<code>Dune Analysis</code>都是基于事件工作的。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础16-18</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%8016-18/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%8016-18/</url>
      
        <content type="html"><![CDATA[<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p><code>solidity</code>中允许函数进行重载（<code>overloading</code>），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p><h3 id="函数重载-1"><a href="#函数重载-1" class="headerlink" title="函数重载"></a>函数重载</h3><p>举个例子，我们可以定义两个都叫<code>saySomething()</code>的函数，一个没有任何参数，输出<code>&quot;Nothing&quot;</code>；另一个接收一个<code>string</code>参数，输出这个<code>string</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function saySomething() public pure returns(string memory)&#123;</span><br><span class="line">    return(&quot;Nothing&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function saySomething(string memory something) public pure returns(string memory)&#123;</span><br><span class="line">    return(something);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>&#x3D;&#x3D;最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。关于函数选择器的具体内容可参考<a href="https://github.com/AmazingAng/WTFSolidity/tree/main/29_Selector">Solidity极简入门: 29. 函数选择器Selector</a>。&#x3D;&#x3D;</p><p>以 <code>Overloading.sol</code> 合约为例，在 Remix 上编译部署后，分别调用重载函数 <code>saySomething()</code> 和 <code>saySomething(string memory something)</code>，可以看到他们返回了不同的结果，被区分为不同的函数。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8016-18/16-1-02e5e7643e93251800ec337e341a58a4.jpg" alt="img"></p><h3 id="实参匹配（Argument-Matching）"><a href="#实参匹配（Argument-Matching）" class="headerlink" title="实参匹配（Argument Matching）"></a>实参匹配（Argument Matching）</h3><p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫<code>f()</code>的函数，一个参数为<code>uint8</code>，另一个为<code>uint256</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">    out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">    out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;我们调用<code>f(50)</code>，因为<code>50</code>既可以被转换为<code>uint8</code>，也可以被转换为<code>uint256</code>，因此会报错。&#x3D;&#x3D;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>中函数重载的基本用法：名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。</p><p>&#x3D;&#x3D;<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。&#x3D;&#x3D;</p><p>最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）</p><h2 id="函数重载有什么用"><a href="#函数重载有什么用" class="headerlink" title="函数重载有什么用"></a>函数重载有什么用</h2><p>函数重载（Function Overloading）是一种编程技术，允许在同一个作用域内创建多个同名函数，但这些函数的参数列表（参数类型或参数数量）不同。在Solidity智能合约编程中，函数重载用于提供多个具有相同名称但接受不同参数的函数版本，这使得合约的功能更加灵活和强大。函数重载的主要用途包括：</p><h3 id="提高代码的可读性和易用性"><a href="#提高代码的可读性和易用性" class="headerlink" title="提高代码的可读性和易用性"></a>提高代码的可读性和易用性</h3><p>通过使用相同的函数名来执行类似的操作，但针对不同的参数类型或数量，可以使代码更容易理解和使用。调用者可以根据他们提供的参数类型和数量，选择最合适的函数版本执行。</p><h3 id="实现多态"><a href="#实现多态" class="headerlink" title="实现多态"></a>实现多态</h3><p>函数重载是多态的一种形式，允许相同的函数调用根据调用时提供的参数类型或数量，映射到不同的函数实现上。这增加了合约的灵活性，允许开发者根据不同的使用场景优雅地处理不同类型的数据。</p><h3 id="简化函数命名"><a href="#简化函数命名" class="headerlink" title="简化函数命名"></a>简化函数命名</h3><p>开发者不需要为执行相似操作的不同函数版本想出不同的名字，这样可以避免在合约接口中出现大量几乎相同功能的函数，只是因为它们的参数类型或数量不同。例如，一个处理支付的函数，无论是接收一个地址和金额，还是接收一个地址数组和金额数组，都可以命名为<code>pay</code>，只是参数不同。</p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>在某些情况下，函数重载可以帮助组织和模块化代码。例如，你可能有一个基础操作的简单版本和一个支持更多自定义选项的高级版本。通过重载，可以保持这些函数在逻辑上紧密相关，而不是分散在合约中。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个资产交易的智能合约，你可能需要一个<code>transfer</code>函数来处理不同类型的资产转移，如下所示：</p><ul><li><code>transfer(address to, uint256 amount)</code>：转移代币到指定地址。</li><li><code>transfer(address to, uint256 tokenId)</code>：转移特定ID的NFT到指定地址。</li></ul><p>在这个例子中，<code>transfer</code>函数被重载来处理不同类型的资产，使得同一合约能够以统一的方式处理多种转账操作。</p><p>总的来说，函数重载增加了Solidity合约的表达能力，使开发者能够以更直观和灵活的方式设计合约接口。</p><h2 id="面向对象编程（Object-Oriented-Programming-OOP）的三大特点是："><a href="#面向对象编程（Object-Oriented-Programming-OOP）的三大特点是：" class="headerlink" title="面向对象编程（Object-Oriented Programming, OOP）的三大特点是："></a>面向对象编程（Object-Oriented Programming, OOP）的三大特点是：</h2><ol><li><p><strong>封装（Encapsulation）</strong>：</p><ul><li>封装是指将数据（属性）和操作数据的方法（方法或函数）捆绑在一起形成类（Class）的过程。</li><li>类通过暴露有限的接口来与外部交互，隐藏了内部的实现细节，从而提高了安全性和可维护性。</li><li>封装有助于实现信息隐藏，使得对象的状态只能通过定义的接口进行访问和修改。</li></ul></li><li><p><strong>继承（Inheritance）</strong>：</p><ul><li>继承是指一个类（子类或派生类）可以继承另一个类（父类或基类）的属性和方法。</li><li>子类可以通过继承从父类中获得已有的功能，同时可以添加新的功能或重写已有的方法。</li><li>继承提高了代码的重用性和扩展性，减少了重复编码的工作量。</li></ul></li><li><p><strong>多态（Polymorphism）</strong>：</p><ul><li>多态是指同一个方法名可以在不同的对象上有不同的实现。</li><li>多态性允许以统一的方式处理不同类型的对象，通过向上转型和动态绑定实现。</li><li>多态性提高了代码的灵活性和可扩展性，使得程序更加易于理解和维护。</li></ul></li></ol><p>这三个特点共同构成了面向对象编程的核心思想，使得程序设计更加模块化、可重用和易于理解。</p><h1 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约</h1><p>这一讲，我们用<code>ERC721</code>的引用的库合约<code>String</code>为例介绍<code>solidity</code>中的库合约（<code>library</code>），并总结了常用的库函数。</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8016-18/HJC0UjkALdrL8a2BmAE2J.jpeg" alt="库合约：站在巨人的肩膀上"></p><p>&#x3D;&#x3D;</p><p>他和普通合约主要有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接收以太币</li><li>不可以被销毁</li></ol><p>&#x3D;&#x3D;</p><h2 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a>Strings库合约</h2><p>&#x3D;&#x3D;注意Strings库合约跟string类型不一样&#x3D;&#x3D;</p><p><code>Strings库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他主要包含两个函数，<code>toString()</code>将<code>uint256</code>转为<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为<code>16进制</code>，再转换为<code>string</code>。<code>toHexString</code>是重载函数，有两个函数</p><h3 id="如何使用库合约"><a href="#如何使用库合约" class="headerlink" title="如何使用库合约"></a>如何使用库合约</h3><p>我们用String库函数的toHexString()来演示两种使用库合约中函数的办法。</p><p><strong>1. 利用using for指令</strong></p><p>指令<code>using A for B;</code>可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 通过库合约名称调用库函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们部署合约并输入<code>170</code>测试一下，两种方法均能返回正确的<code>16进制string</code> “0xaa”。证明我们调用库函数成功！</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8016-18/bzB_JDC9f5VWHRjsjQyQa.png" alt="成功调用库函数"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们用<code>ERC721</code>的引用的库函数<code>String</code>为例介绍<code>solidity</code>中的库函数（<code>Library</code>）。99%的开发者都不需要自己去写库合约，会用大神写的就可以了。我们只需要知道什么情况该用什么库合约。常用的有：</p><ol><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>uint256</code>转换为<code>String</code></li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库函数</li></ol><p>是的，使用库（Libraries）函数在某些情况下可以帮助减少智能合约的Gas消耗。库在Solidity中是一种特殊类型的合约，旨在被部署一次，然后由其他合约通过委托调用（delegatecall）来复用其函数。这种设计可以在多个合约之间共享代码逻辑，从而减少重复代码的部署，进一步减少Gas消耗。以下是库函数减少Gas消耗的几种方式：</p><h3 id="1-代码复用"><a href="#1-代码复用" class="headerlink" title="1. 代码复用"></a>1. 代码复用</h3><p>通过将常用的逻辑和函数放在库中，多个合约可以共享这些代码，而不是在每个合约中重复相同的代码。这减少了链上存储的总量，因为库代码只需要部署一次，而不是与每个合约一起部署。</p><h3 id="2-优化存储访问"><a href="#2-优化存储访问" class="headerlink" title="2. 优化存储访问"></a>2. 优化存储访问</h3><p>库可以用来优化数据的存储和访问模式。例如，Solidity的<code>SafeMath</code>库提供了安全的数学运算，防止溢出，而不增加额外的存储开销。通过优化数据处理，可以减少执行操作所需的Gas。</p><h3 id="3-减少部署成本"><a href="#3-减少部署成本" class="headerlink" title="3. 减少部署成本"></a>3. 减少部署成本</h3><p>库的部署是独立于使用它的合约进行的。一旦库被部署，任何合约都可以通过委托调用来访问其函数，而不需要再次部署库代码。这意味着合约的部署成本降低了，因为合约体积变小。</p><h3 id="4-简化合约代码"><a href="#4-简化合约代码" class="headerlink" title="4. 简化合约代码"></a>4. 简化合约代码</h3><p>通过将复杂逻辑移至库中，合约代码本身变得更简单、更清晰。这不仅有助于减少直接的Gas消耗，而且还使得合约更容易审核，减少了因错误或低效率代码导致的潜在Gas浪费。</p><p>&#x3D;&#x3D;然而，值得注意的是，使用库并不总是导致Gas成本的减少。委托调用（delegatecall）本身是有成本的，并且如果库函数相对简单，那么使用库可能不会带来显著的Gas节省。因此，是否使用库以及如何使用库，应该根据具体情况和需求来决定，以确保能有效优化Gas消耗。&#x3D;&#x3D;</p><h1 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h1><p><code>solidity</code>支持利用<code>import</code>关键字导入其他源代码中的合约，让开发更加模块化。</p><h2 id="import用法"><a href="#import用法" class="headerlink" title="import用法"></a><code>import</code>用法</h2><ul><li>通过源文件相对位置导入，例子：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件结构</span><br><span class="line">├── Import.sol</span><br><span class="line">└── Yeye.sol</span><br><span class="line"></span><br><span class="line">// 通过文件相对位置import</span><br><span class="line">import &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure><ul><li>通过源文件网址导入网上的合约，例子：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过网址引用</span><br><span class="line">import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;;</span><br></pre></td></tr></table></figure><ul><li>通过<code>npm</code>的目录导入，例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br></pre></td></tr></table></figure><p>OpenZeppelin 是一个在区块链开发领域非常知名的库，专门为智能合约开发提供安全的基础设施。它主要用于构建在以太坊和其他兼容EVM（以太坊虚拟机）的区块链上的智能合约。OpenZeppelin 的库和工具广泛应用于实现代币发行（如 ERC-20 和 ERC-721 代币标准）、访问控制、安全合约升级以及各种金融工具。</p><h3 id="OpenZeppelin-主要特点包括："><a href="#OpenZeppelin-主要特点包括：" class="headerlink" title="OpenZeppelin 主要特点包括："></a>OpenZeppelin 主要特点包括：</h3><ol><li><p><strong>安全性</strong>：提供经过严格审核和社区验证的智能合约实现，帮助开发人员避免常见的安全问题，如重入攻击、整数溢出等。</p></li><li><p><strong>可复用性</strong>：通过提供标准化的合约模板（如代币合约、所有权管理合约等），简化了开发流程并提高了代码的可复用性。</p></li><li><p><strong>易于集成</strong>：OpenZeppelin 的合约可以轻松集成到任何基于Solidity的项目中，支持通过 npm 安装，方便与其他项目或库结合使用。</p></li><li><p><strong>社区支持</strong>：拥有活跃的开发社区和广泛的用户基础，为开发者提供问题解答、最新的安全实践和持续的库更新。</p></li><li><p><strong>升级插件</strong>：提供了升级插件支持智能合约的透明升级，允许开发者修复、更新和改进已部署的合约。</p></li></ol><h3 id="使用场景示例："><a href="#使用场景示例：" class="headerlink" title="使用场景示例："></a>使用场景示例：</h3><ul><li><p><strong>创建代币</strong>：OpenZeppelin 提供了多种代币合约实现，如 ERC-20（标准化代币）、ERC-721（非同质化代币，即NFT）、ERC-1155（多代币标准）等。</p></li><li><p><strong>访问控制</strong>：提供了多种访问控制机制，如 <code>Ownable</code> 和 <code>Roles</code>，允许合约的创建者控制谁可以调用合约的特定功能。</p></li><li><p><strong>金融工具</strong>：例如创建可在特定条件下执行的智能合约，如基于时间的锁定或投票机制。</p></li><li><p>通过<code>全局符号</code>导入特定的合约，例子：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure><ul><li>引用(<code>import</code>)在代码中的位置为：在声明版本号之后，在其余代码之前。</li></ul><h2 id="测试导入结果"><a href="#测试导入结果" class="headerlink" title="测试导入结果"></a>测试导入结果</h2><p>我们可以用下面这段代码测试是否成功导入了外部源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Import &#123;</span><br><span class="line">    // 成功导入Address库</span><br><span class="line">    using Address for address;</span><br><span class="line">    // 声明yeye变量</span><br><span class="line">    Yeye yeye = new Yeye();</span><br><span class="line"></span><br><span class="line">    // 测试是否能调用yeye的函数</span><br><span class="line">    function test() external&#123;</span><br><span class="line">        yeye.hip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8016-18/18-1-be3039b3dda4b85f9a3197fbe6102abb.png" alt="result"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了利用<code>import</code>关键字导入外部源代码的方法。通过<code>import</code>关键字，可以引用我们写的其他文件中的合约或者函数，也可以直接导入别人写好的代码，非常方便。</p><p>在Solidity中，<code>import</code>语句用于导入其他源文件中定义的全局符号，这些符号包括合约、库、接口、其他类型的定义以及函数等。使用<code>import</code>可以组织和重用代码，允许开发者将合约逻辑分散在多个文件中，便于管理和维护。<code>import</code>不仅限于接口，它可以导入任何在其他Solidity文件中定义的公共或外部可见的元素，但不能导入私有变量或内部变量，因为这些元素是封装在其原始合约中的，不对外部可见。</p><p>当你想要在Solidity中单独导入被导入文件中的全局符号（如合约、接口、库、函数、结构体等）时，这些符号应该与合约并列在文件结构中，而不是被包含在另一个合约的内部。这样，每个全局符号都被视为独立的定义，可以通过<code>import</code>语句单独导入到其他合约或文件中。</p><p>这种组织方式有助于提高代码的模块化和可重用性，允许开发者仅导入他们需要的部分，而不是整个文件。例如，如果你有一个定义了多个合约、库或其他全局符号的Solidity文件，你可以选择性地只导入需要的那部分符号到你的合约中，这样做可以减少编译后代码的大小，提高合约的效率。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础4-6</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-4-函数输出-return"><a href="#Solidity极简入门-4-函数输出-return" class="headerlink" title="Solidity极简入门: 4. 函数输出 return"></a>Solidity极简入门: 4. 函数输出 return</h1><p>这一讲，我们将介绍<code>Solidity</code>函数输出，包括：返回多种变量，命名式返回，以及利用解构式赋值读取全部和部分返回值。</p><h2 id="返回值-return和returns"><a href="#返回值-return和returns" class="headerlink" title="返回值 return和returns"></a>返回值 return和returns</h2><p><code>Solidity</code>有两个关键字与函数输出相关：<code>return</code>和<code>returns</code>，他们的区别在于：</p><ul><li><p><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</p></li><li><p><code>return</code>用于函数主体中，返回指定的变量。</p> <span id="more"></span></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回多个变量</span><br><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;</span><br><span class="line">        return(1, true, [uint256(1),2,5]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们声明了<code>returnMultiple()</code>函数将有多个输出：<code>returns(uint256, bool, uint256[3] memory)</code>，接着我们在函数主体中用<code>return(1, true, [uint256(1),2,5])</code>确定了返回值。</p><h2 id="命名式返回"><a href="#命名式返回" class="headerlink" title="命名式返回"></a>命名式返回</h2><p>我们可以在<code>returns</code>中标明返回变量的名称，这样<code>solidity</code>会自动给这些变量初始化，并且自动返回这些函数的值，不需要加<code>return</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 命名式返回</span><br><span class="line">function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;</span><br><span class="line">    _number = 2;</span><br><span class="line">    _bool = false; </span><br><span class="line">    _array = [uint256(3),2,1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们用<code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code>声明了返回变量类型以及变量名。这样，我们在主体中只需要给变量<code>_number</code>，<code>_bool</code>和<code>_array</code>赋值就可以自动返回了。</p><p>当然，你也可以在命名式返回中用<code>return</code>来返回变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命名式返回，依然支持return</span><br><span class="line">function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;</span><br><span class="line">    return(1, true, [uint256(1),2,5]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p><code>solidity</code>使用解构式赋值的规则，支持读取函数的全部或部分返回值。</p><ul><li>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint256 _number;</span><br><span class="line">bool _bool;</span><br><span class="line">uint256[3] memory _array;</span><br><span class="line">(_number, _bool, _array) = returnNamed();</span><br></pre></td></tr></table></figure><ul><li>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(, _bool2, ) = returnNamed();</span><br></pre></td></tr></table></figure><p><strong>使用场景和好处</strong></p><ul><li><strong>代码简洁</strong>：使用结构式赋值可以使代码更加简洁易读，特别是在处理多个返回值或复杂数据结构时。</li><li><strong>减少错误</strong>：减少了额外的赋值语句，降低了因错误处理不当导致的bug。</li><li><strong>提高开发效率</strong>：直接在一行代码中完成多个变量的赋值，提高了开发效率。</li><li><strong>便于维护</strong>：代码更加简洁明了，便于后期维护和理解。</li></ul><p>结构式赋值是现代编程语言中的一个非常有用的特性，它能够让数据操作更加直观和高效。</p><h2 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ul><li>部署合约后查看三种返回方式的结果</li></ul><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/4-1-3c115fdc5afcb11e3f9eb51b8e2abbd8.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍函数的返回值<code>return</code>和<code>returns</code>，包括：返回多种变量，命名式返回，以及利用解构式赋值读取全部和部分返回值。</p><h1 id="Solidity极简入门-5-变量数据存储和作用域-storage-memory-calldata"><a href="#Solidity极简入门-5-变量数据存储和作用域-storage-memory-calldata" class="headerlink" title="Solidity极简入门: 5. 变量数据存储和作用域 storage&#x2F;memory&#x2F;calldata"></a>Solidity极简入门: 5. 变量数据存储和作用域 storage&#x2F;memory&#x2F;calldata</h1><h2 id="Solidity中的引用类型"><a href="#Solidity中的引用类型" class="headerlink" title="Solidity中的引用类型"></a>Solidity中的引用类型</h2><p>**引用类型(Reference Type)**：包括数组（<code>array</code>），结构体（<code>struct</code>）和映射（<code>mapping</code>），这类变量占空间大，赋值时候直接传递地址（类似指针）。&#x3D;&#x3D;由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。&#x3D;&#x3D;</p><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>solidity数据存储位置有三类：<code>storage</code>，<code>memory</code>和<code>calldata</code>。不同存储位置的<code>gas</code>成本不同。<code>storage</code>类型的数据存在链上，类似计算机的硬盘，消耗<code>gas</code>多；<code>memory</code>和<code>calldata</code>类型的临时存在内存里，消耗<code>gas</code>少。大致用法：</p><ol><li><code>storage</code>：合约里的&#x3D;&#x3D;状态变量默认都是<code>storage</code>&#x3D;&#x3D;，存储在链上。</li><li><code>memory</code>：函数里的参数和临时变量一般用<code>memory</code>，存储在内存中，不上链。</li><li><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量不能修改（<code>immutable</code>），一般用于函数的参数。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123;</span><br><span class="line">    //参数为calldata数组，不能被修改</span><br><span class="line">    // _x[0] = 0 //这样修改会报错</span><br><span class="line">    return(_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/5-1-9d00a21842c77b3911aaf419f67ad691.png" alt="5-1.png"></p><h3 id="数据位置和赋值规则"><a href="#数据位置和赋值规则" class="headerlink" title="数据位置和赋值规则"></a>数据位置和赋值规则</h3><p>&#x3D;&#x3D;在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。&#x3D;&#x3D;规则如下：</p><ol><li><code>storage</code>（合约的状态变量）赋值给&#x3D;&#x3D;本地（指的基本都是函数里面）&#x3D;&#x3D;<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint[] x = [1,2,3]; // 状态变量：数组 x</span><br><span class="line"></span><br><span class="line">function fStorage() public&#123;</span><br><span class="line">    //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x</span><br><span class="line">    uint[] storage xStorage = x;</span><br><span class="line">    xStorage[0] = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/5-2-91bae5b0b86b0e55210cac541a6edee5.png" alt="5-2.png"></p><ol><li><code>storage</code>赋值给<code>memory</code>，会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint[] x = [1,2,3]; // 状态变量：数组 x</span><br><span class="line"></span><br><span class="line">function fMemory() public view&#123;</span><br><span class="line">    //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x</span><br><span class="line">    uint[] memory xMemory = x;</span><br><span class="line">    xMemory[0] = 100;</span><br><span class="line">    xMemory[1] = 200;</span><br><span class="line">    uint[] memory xMemory2 = x;</span><br><span class="line">    xMemory2[0] = 300;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/5-3-979f3cbffbbe20ff5df5c143384610e4.png" alt="5-3.png"></p><ol><li><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</li><li>其他情况，变量赋值给<code>storage</code>，会创建独立的副本，修改其中一个不会影响另一个。</li></ol><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Variables &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    uint public y;</span><br><span class="line">    string public z;</span><br></pre></td></tr></table></figure><p>我们可以在函数里更改状态变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() external&#123;</span><br><span class="line">    // 可以在函数里更改状态变量的值</span><br><span class="line">    x = 5;</span><br><span class="line">    y = 2;</span><br><span class="line">    z = &quot;0xAA&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bar() external pure returns(uint)&#123;</span><br><span class="line">    uint xx = 1;</span><br><span class="line">    uint yy = 3;</span><br><span class="line">    uint zz = xx + yy;</span><br><span class="line">    return(zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function global() external view returns(address, uint, bytes memory)&#123;</span><br><span class="line">    address sender = msg.sender;</span><br><span class="line">    uint blockNum = block.number;</span><br><span class="line">    bytes memory data = msg.data;</span><br><span class="line">    return(sender, blockNum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子里，我们使用了3个常用的全局变量：<code>msg.sender</code>, <code>block.number</code>和<code>msg.data</code>，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p><ul><li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</li><li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li><li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li><li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li><li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li><li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li><li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li><li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li><li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li><li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的<code>wei</code>值</li></ul><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/5-4-5ee425310e1666a20575f2a8330c55cb.png" alt="5-4.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了<code>solidity</code>中的引用类型，数据位置和变量的作用域。重点是<code>storage</code>, <code>memory</code>和<code>calldata</code>三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低<code>gas</code>。下一讲我们会介绍引用类型中的数组。&#x3D;&#x3D;只用记住：合约中状态变量storage赋值给本地storage是引用，合约中memory赋值给本地变量memory也是引用，其他都是创建副本，改变一个其中另一个不会改变&#x3D;&#x3D;</p><h1 id="Solidity极简入门-6-引用类型-array-struct"><a href="#Solidity极简入门-6-引用类型-array-struct" class="headerlink" title="Solidity极简入门: 6. 引用类型, array, struct"></a>Solidity极简入门: 6. 引用类型, array, struct</h1><p>这一讲，我们将介绍<code>solidity</code>中的两个重要变量类型：数组（<code>array</code>）和结构体（<code>struct</code>）。</p><h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h2><p>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p><ul><li>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度 Array    uint[8] array1;    bytes1[5] array2;    address[100] array3;固定长度 Array</span><br><span class="line">uint[8] 数组1;</span><br><span class="line">字节1[5] 数组2;</span><br><span class="line">地址[100] 数组3;</span><br></pre></td></tr></table></figure><ul><li>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可变长度 Array</span><br><span class="line">uint[] array4;</span><br><span class="line">bytes1[] array5;</span><br><span class="line">address[] array6;</span><br><span class="line">bytes array7;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>。另外，不能用<code>byte[]</code>声明单字节数组，可以使用<code>bytes</code>或<code>bytes1[]</code>。在gas上，<code>bytes</code>比<code>bytes1[]</code>便宜。因为<code>bytes1[]</code>在<code>memory</code>中要增加31个字节进行填充，会产生额外的gas。但是在<code>storage</code>中，由于内存紧密打包，不存在字节填充。</p><h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p>在solidity里，创建数组有一些规则：</p><ul><li>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// memory动态数组</span><br><span class="line">uint[] memory array8 = new uint[](5);</span><br><span class="line">bytes memory array9 = new bytes(9);</span><br></pre></td></tr></table></figure><ul><li>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而<code>[uint(1),2,3]</code>里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。 下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] memory) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果创建的是动态数组，你需要一个一个元素的赋值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory x = new uint[](3);</span><br><span class="line">x[0] = 1;</span><br><span class="line">x[1] = 3;</span><br><span class="line">x[2] = 4;</span><br></pre></td></tr></table></figure><h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul><li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li><li><code>push()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素。</li><li><code>push(x)</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li><li><code>pop()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li></ul><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/6-1-ff58f00a7e037fcd318401ca2bc350b6.png" alt="6-1.png"></p><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。创建结构体的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 结构体</span><br><span class="line">struct Student&#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    uint256 score; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student; // 初始一个student结构体</span><br></pre></td></tr></table></figure><p>给结构体赋值的两种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  给结构体赋值</span><br><span class="line">// 方法1:在函数中创建一个storage的struct引用</span><br><span class="line">function initStudent1() external&#123;</span><br><span class="line">    Student storage _student = student; // assign a copy of student</span><br><span class="line">    _student.id = 11;</span><br><span class="line">    _student.score = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/6-2-991e08767256fcc39717f429da21f05d.png" alt="6-2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 方法2:直接引用状态变量的struct</span><br><span class="line">function initStudent2() external&#123;</span><br><span class="line">    student.id = 1;</span><br><span class="line">    student.score = 80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%804-6/6-3-7ccb3cbebd7eff492292a171a8de1852.png" alt="6-3.png"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了solidity中数组（<code>array</code>）和结构体（<code>struct</code>）的基本用法。下一讲我们将介绍solidity中的哈希表——映射（<code>mapping</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础7-9</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-7-映射类型-mapping"><a href="#Solidity极简入门-7-映射类型-mapping" class="headerlink" title="Solidity极简入门: 7. 映射类型 mapping"></a>Solidity极简入门: 7. 映射类型 mapping</h1><h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; address) public idToAddress; // id映射到地址</span><br><span class="line">mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h2><p>&#x3D;&#x3D;这里的几个规则是重点&#x3D;&#x3D;</p><ul><li><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择<code>solidity</code>默认的类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。下面这个例子会报错，因为<code>_KeyType</code>使用了我们自定义的结构体：</li><li>&#x3D;&#x3D;key只能用默认的，但是value自定义的都可以&#x3D;&#x3D;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 我们定义一个结构体 Struct</span><br><span class="line">struct Student&#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    uint256 score; </span><br><span class="line">&#125;</span><br><span class="line"> mapping(Student =&gt; uint) public testVar;</span><br></pre></td></tr></table></figure><ul><li><strong>规则2</strong>：&#x3D;&#x3D;映射的存储位置必须是<code>storage</code>&#x3D;&#x3D;，因此可以用于合约的状态变量，函数中的<code>storage</code>变量，和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</li><li><strong>规则3</strong>：如果映射声明为<code>public</code>，那么<code>solidity</code>会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</li><li><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function writeMap (uint _Key, address _Value) public&#123;</span><br><span class="line">    idToAddress[_Key] = _Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h2><ul><li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li><li><strong>原理2</strong>: 映射使用<code>keccak256(key)</code>当成offset存取value。</li><li><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</li></ul><h2 id="在Remix上验证-以-Mapping-sol为例"><a href="#在Remix上验证-以-Mapping-sol为例" class="headerlink" title="在Remix上验证 (以 Mapping.sol为例)"></a>在Remix上验证 (以 <code>Mapping.sol</code>为例)</h2><ul><li><p>映射示例 1 部署</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/7-1-2768f65eec9dbbc8771275b45c937e96.jpg" alt="7-1"></p></li><li><p>映射示例 2 初始值</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/7-2-886db6cf3743df280acac78c151971f3.jpg" alt="7-2"></p></li><li><p>映射示例 3 key-value pair</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/7-3-88745249067310f5e280dd60b2560adb.jpg" alt="7-3"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>中哈希表——映射（<code>Mapping</code>）的用法。至此，我们已经学习了所有常用变量种类，之后我们会学习控制流<code>if-else</code>,<code> while</code>等。</p><h1 id="Solidity极简入门-8-变量初始值"><a href="#Solidity极简入门-8-变量初始值" class="headerlink" title="Solidity极简入门: 8. 变量初始值"></a>Solidity极简入门: 8. 变量初始值</h1><h2 id="变量初始值"><a href="#变量初始值" class="headerlink" title="变量初始值"></a>变量初始值</h2><p>在<code>solidity</code>中，声明但没赋值的变量都有它的初始值或默认值。这一讲，我们将介绍常用变量的初始值。</p><h3 id="值类型初始值"><a href="#值类型初始值" class="headerlink" title="值类型初始值"></a>值类型初始值</h3><ul><li><p><code>boolean</code>: <code>false</code></p></li><li><p><code>string</code>: <code>&quot;&quot;</code></p></li><li><p><code>int</code>: <code>0</code></p></li><li><p><code>uint</code>: <code>0</code></p></li><li><p><code>enum</code>: 枚举中的第一个元素</p></li><li><p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p></li><li><pre><code>function<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `internal`: 空白方程</span><br><span class="line">  - `external`: 空白方程</span><br><span class="line"></span><br><span class="line">可以用`public`变量的`getter`函数验证上面写的初始值是否正确：</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">    bool public _bool; // false</span><br><span class="line">    string public _string; // &quot;&quot;</span><br><span class="line">    int public _int; // 0</span><br><span class="line">    uint public _uint; // 0</span><br><span class="line">    address public _address; // 0x0000000000000000000000000000000000000000</span><br><span class="line"></span><br><span class="line">    enum ActionSet &#123; Buy, Hold, Sell&#125;</span><br><span class="line">    ActionSet public _enum; // 第1个内容Buy的索引0</span><br><span class="line"></span><br><span class="line">    function fi() internal&#123;&#125; // internal空白方程 </span><br><span class="line">    function fe() external&#123;&#125; // external空白方程 </span><br></pre></td></tr></table></figure></code></pre></li></ul><p>&#x3D;&#x3D;注意bytes1 初始值是0x00&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>bytes1</code> 是一种固定长度的字节数组，只能包含一个字节（8位）。它可以用来存储任何8位的数据，包括整数、字符、字节等。但要注意的是，<code>bytes1</code> 中的数据并不被解释为整数类型，而是作为字节序列来处理。bytes也可以存储其他数据类型，比如字符串&#x3D;&#x3D;</p><h3 id="引用类型初始值"><a href="#引用类型初始值" class="headerlink" title="引用类型初始值"></a>引用类型初始值</h3><h3 id="映射mapping-所有元素都为其默认值的mapping"><a href="#映射mapping-所有元素都为其默认值的mapping" class="headerlink" title="映射mapping: 所有元素都为其默认值的mapping"></a>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></h3><ul><li>结构体<code>struct</code>: 所有成员设为其默认值的结构体</li><li>数组<code>array</code><ul><li>动态数组: <code>[]</code></li><li>静态数组（定长）: 所有成员设为其默认值的静态数组</li></ul></li></ul><p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Reference Types</span><br><span class="line">uint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0]</span><br><span class="line">uint[] public _dynamicArray; // `[]`</span><br><span class="line">mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping</span><br><span class="line">// 所有成员设为其默认值的结构体 0, 0</span><br><span class="line">struct Student&#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    uint256 score; </span><br><span class="line">&#125;</span><br><span class="line">Student public student;</span><br></pre></td></tr></table></figure><h3 id="delete操作符"><a href="#delete操作符" class="headerlink" title="delete操作符"></a><code>delete</code>操作符</h3><p><code>delete a</code>会让变量<code>a</code>的值变为初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// delete操作符</span><br><span class="line">bool public _bool2 = true; </span><br><span class="line">function d() external &#123;</span><br><span class="line">    delete _bool2; // delete 会让_bool2变为默认值，false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ul><li><p>部署合约查看值类型、引用类型的初始值</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/8-1-bf8a5eafba9f2a6be29c8a116a5465bc.png" alt="img"></p></li><li><p>值类型、引用类型delete操作后的默认值</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/8-2-968b7c57cb793dc524a5665dfae26624.png" alt="img"></p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>中变量的初始值。变量被声明但没有赋值的时候，它的值默认为初始值。不同类型的变量初始值不同，<code>delete</code>操作符可以删除一个变量的值并代替为初始值。</p><h1 id="Solidity极简入门-9-常数-constant和immutable"><a href="#Solidity极简入门-9-常数-constant和immutable" class="headerlink" title="Solidity极简入门: 9. 常数 constant和immutable"></a>Solidity极简入门: 9. 常数 constant和immutable</h1><p>这一讲，我们介绍<code>solidity</code>中两个关键字，<code>constant</code>（常量）和<code>immutable</code>（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以&#x3D;&#x3D;节省<code>gas</code>&#x3D;&#x3D;。另外，只有数值变量可以声明<code>constant</code>和<code>immutable</code>；&#x3D;&#x3D;<code>string</code>和<code>bytes</code>可以声明为<code>constant</code>，但不能为<code>immutable</code>。&#x3D;&#x3D;</p><h2 id="constant和immutable"><a href="#constant和immutable" class="headerlink" title="constant和immutable"></a>constant和immutable</h2><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><p>&#x3D;&#x3D;<code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。string和bytes必须用constant&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// constant变量必须在声明的时候初始化，之后不能改变</span><br><span class="line">uint256 constant CONSTANT_NUM = 10;</span><br><span class="line">string constant CONSTANT_STRING = &quot;0xAA&quot;;</span><br><span class="line">bytes constant CONSTANT_BYTES = &quot;WTF&quot;;</span><br><span class="line">address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;</span><br></pre></td></tr></table></figure><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// immutable变量可以在constructor里初始化，之后不能改变</span><br><span class="line">uint256 public immutable IMMUTABLE_NUM = 9999999999;</span><br><span class="line">address public immutable IMMUTABLE_ADDRESS;</span><br><span class="line">uint256 public immutable IMMUTABLE_BLOCK;</span><br><span class="line">uint256 public immutable IMMUTABLE_TEST;</span><br></pre></td></tr></table></figure><p>你可以使用全局变量例如<code>address(this)</code>，<code>block.number</code> ，或者自定义的函数给<code>immutable</code>变量初始化。在下面这个例子，我们利用了<code>test()</code>函数给<code>IMMUTABLE_TEST</code>初始化为<code>9</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 利用constructor初始化immutable变量，因此可以利用</span><br><span class="line">constructor()&#123;</span><br><span class="line">    IMMUTABLE_ADDRESS = address(this);</span><br><span class="line">    IMMUTABLE_BLOCK = block.number;</span><br><span class="line">    IMMUTABLE_TEST = test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() public pure returns(uint256)&#123;</span><br><span class="line">    uint256 what = 9;</span><br><span class="line">    return(what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在remix上验证-1"><a href="#在remix上验证-1" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ol><li><p>部署好合约之后，通过remix上的<code>getter</code>函数，能获取到<code>constant</code>和<code>immutable</code>变量初始化好的值。</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/9-1-4dd7d40c9799d42c60e4793394a4eb5e.png" alt="9-1.png"></p></li><li><p><code>constant</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Cannot assign to a constant variable.</code>的错误。</p></li></ol><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%807-9/9-2-5b85f9969dff8fbeb78cac9f8d4089ce.png" alt="9-2.png"></p><ol><li><p><code>immutable</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Immutable state variable already initialized.</code>的错误。</p><p><img src="data:image/png;base64,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" alt="9-3.png"></p></li></ol><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍<code>solidity</code>中两个关键字，<code>constant</code>（常量）和<code>immutable</code>（不变量），让不应该变的变量保持不变。这样的做法能在节省<code>gas</code>的同时提升合约的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础16-18</title>
      <link href="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/"/>
      <url>/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-19-接收ETH-receive和fallback"><a href="#Solidity极简入门-19-接收ETH-receive和fallback" class="headerlink" title="Solidity极简入门: 19. 接收ETH receive和fallback"></a>Solidity极简入门: 19. 接收ETH receive和fallback</h1><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用（代理合约proxy contract）</li></ol><p>注意⚠️：在solidity 0.6.x版本之前，语法上只有 <code>fallback()</code> 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 <code>fallback()</code> 函数拆分成 <code>receive()</code> 和 <code>fallback()</code> 两个函数。</p><p>我们这一讲主要讲接收ETH的情况。</p><span id="more"></span><h2 id="接收ETH函数-receive"><a href="#接收ETH函数-receive" class="headerlink" title="接收ETH函数 receive"></a>接收ETH函数 receive</h2><p><code>receive()</code>只用于处理接收<code>ETH</code>。一个合约最多有一个<code>receive()</code>函数，声明方式与一般函数不一样，不需要<code>function</code>关键字：<code>receive() external payable &#123; ... &#125;</code>。<code>receive()</code>函数不能有任何的参数，不能返回任何值，必须包含<code>external</code>和<code>payable</code>。</p><p>当合约接收ETH的时候，<code>receive()</code>会被触发。<code>receive()</code>最好不要执行太多的逻辑因为如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code>，<code>receive()</code>太复杂可能会触发<code>Out of Gas</code>报错；如果用<code>call</code>就可以自定义<code>gas</code>执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p><p>我们可以在<code>receive()</code>里发送一个<code>event</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些恶意合约，会在<code>receive()</code> 函数（老版本的话，就是 <code>fallback()</code> 函数）嵌入恶意消耗<code>gas</code>的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p><h2 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h2><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</p><p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fallback</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line">    emit fallbackCalled(msg.sender, msg.value, msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="receive和fallback的区别"><a href="#receive和fallback的区别" class="headerlink" title="receive和fallback的区别"></a>receive和fallback的区别</h2><p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">触发fallback() 还是 receive()?</span><br><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure><p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p><p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约<strong>直接</strong>发送<code>ETH</code>将会报错（你仍可以通过带有<code>payable</code>的函数向合约发送<code>ETH</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract jieshou&#123;</span><br><span class="line">    event Receive(address sender,uint256 value);</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        emit Receive(msg.sender,msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Fallback(address sender, uint256 value,bytes data);</span><br><span class="line"></span><br><span class="line">    fallback() external payable&#123;</span><br><span class="line">        emit Fallback(msg.sender,msg.value,msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceof() public view returns(uint256)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;就算value等于0，我填上calldata,他也会触发fallback(),也就是说想要有msg.data（calldata）就必须有fallback()函数&#x3D;&#x3D;</p><h2 id="Remix-演示"><a href="#Remix-演示" class="headerlink" title="Remix 演示"></a>Remix 演示</h2><ol><li><p>首先在 Remix 上部署合约 “Fallback.sol”。</p></li><li><p>“VALUE” 栏中填入要发送给合约的金额（单位是 Wei），然后点击 “Transact”。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/19-1-4ba34e6d9cbb74a98a3c8affd59bc583.jpg" alt="img"></p></li><li><p>可以看到交易成功，并且触发了 “receivedCalled” 事件。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/19-2-b933741438ce18210739446f85b8e3c4.jpg" alt="img"></p></li><li><p>“VALUE” 栏中填入要发送给合约的金额（单位是 Wei），”CALLDATA” 栏中填入随意编写的<code>msg.data</code>，然后点击 “Transact”。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/19-3-83c411c3270d886d6ea0535c4cc9660d.jpg" alt="img"></p></li><li><p>可以看到交易成功，并且触发了 “fallbackCalled” 事件。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/19-4-a6bbcb103838f43fe8987b95606b8e27.jpg" alt="img"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我介绍了<code>Solidity</code>中的两种特殊函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用，他们主要用于处理接收<code>ETH</code>和代理合约<code>proxy contract</code>。</p><h1 id="Solidity极简入门-20-发送ETH"><a href="#Solidity极简入门-20-发送ETH" class="headerlink" title="Solidity极简入门: 20. 发送ETH"></a>Solidity极简入门: 20. 发送ETH</h1><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>，其中<code>call()</code>是被鼓励的用法。</p><h2 id="接收ETH合约"><a href="#接收ETH合约" class="headerlink" title="接收ETH合约"></a>接收ETH合约</h2><p>我们先部署一个接收<code>ETH</code>合约<code>ReceiveETH</code>。<code>ReceiveETH</code>合约里有一个事件<code>Log</code>，记录收到的<code>ETH</code>数量和<code>gas</code>剩余。还有两个函数，一个是<code>receive()</code>函数，收到<code>ETH</code>被触发，并发送<code>Log</code>事件；另一个是查询合约<code>ETH</code>余额的<code>getBalance()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract ReceiveETH &#123;</span><br><span class="line">    // 收到eth事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        emit Log(msg.value, gasleft());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署<code>ReceiveETH</code>合约后，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>0</code>。</p><p>&#x3D;&#x3D;gasleft()是什么</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-1-b18baa5867c909e527eca6852945ad46.png" alt="20-1"></p><h2 id="发送ETH合约"><a href="#发送ETH合约" class="headerlink" title="发送ETH合约"></a>发送ETH合约</h2><p>我们将实现三种方法向<code>ReceiveETH</code>合约发送<code>ETH</code>。首先，先在发送ETH合约<code>SendETH</code>中实现<code>payable</code>的<code>构造函数</code>和<code>receive()</code>，让我们能够在部署时和部署后向合约转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><ul><li>用法是<code>接收方地址.transfer(发送ETH数额)</code>。</li><li><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li><li><code>transfer()</code>如果转账失败，会自动<code>revert</code>（回滚交易）。</li></ul><p>代码样例，注意里面的<code>_to</code>填<code>ReceiveETH</code>合约的地址，<code>amount</code>是<code>ETH</code>转账金额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用transfer()发送ETH</span><br><span class="line">function transferETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    _to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署<code>SendETH</code>合约后，对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，发生<code>revert</code>。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-2-572c8ac0dfa42d4ea7fc62de0ff1c5af.png" alt="20-2"></p><p>此时<code>amount</code>为10，<code>value</code>为10，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-3-c48a1c9f41ff2a53095bbf4d0b7767b7.png" alt="20-3"></p><p>在<code>ReceiveETH</code>合约中，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>10</code>。</p><p><img src="data:image/png;base64,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" alt="20-4"></p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><ul><li>用法是<code>接收方地址.send(发送ETH数额)</code>。</li><li><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li><li><code>send()</code>如果转账失败，不会<code>revert</code>。</li><li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li></ul><p>代码样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-5-cb457285c7185c438995bfcc95b6a01d.png" alt="20-5"></p><p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-6-1ae2f81d902c618059d813e5b16cbe4c.png" alt="20-6"></p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>用法是<code>接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</code>。</li><li><code>call()</code>没有<code>gas</code>限制，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。</li><li><code>call()</code>如果转账失败，不会<code>revert</code>。</li><li><code>call()</code>的返回值是<code>(bool, data)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li></ul><p>代码样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-7-bbfe1e7134676767c0a6c9612165ea9e.png" alt="20-7"></p><p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/20-8-5c25a6d4556ce624ff27752f24e85d4a.png" alt="20-8"></p><p>运行三种方法，可以看到，他们都可以成功地向<code>ReceiveETH</code>合约发送<code>ETH</code>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍<code>solidity</code>三种发送<code>ETH</code>的方法：<code>transfer</code>，<code>send</code>和<code>call</code>。</p><ul><li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li><li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li><li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract SendEth&#123;</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">    function transferEth(address payable to,uint amount) external payable&#123;</span><br><span class="line">        to.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function getbalance() external view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125; </span><br><span class="line">    function sendEth(address payable _to,uint256 amount)external payable&#123;</span><br><span class="line">        bool success = _to.send(amount);</span><br><span class="line">        if(!success)&#123;</span><br><span class="line">            revert (&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function callEth(address payable _to,uint256 amount) external payable&#123;</span><br><span class="line">        (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        if(!success)&#123;</span><br><span class="line">            revert (&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract othercontract&#123;</span><br><span class="line">    uint256 private _x = 0;</span><br><span class="line"></span><br><span class="line">    event Log(uint amount,uint gas);</span><br><span class="line"></span><br><span class="line">    function getbalance() view public returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setx(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value,gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getx() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract callcontract&#123;</span><br><span class="line">    function callsetx(address _address, uint256 x) external&#123;</span><br><span class="line">        othercontract(_address).setx(x);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    function callgetx(othercontract _address) external view returns(uint x)&#123;</span><br><span class="line">        x = _address.getx();</span><br><span class="line">    &#125;</span><br><span class="line">    function callgetx2(address _address) external view returns(uint x)&#123;</span><br><span class="line"></span><br><span class="line">        othercontract oc = othercontract(_address);</span><br><span class="line"></span><br><span class="line">        x = oc.getx();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setxTransferETH(address _address,uint x) payable external&#123;</span><br><span class="line">        othercontract(_address).setx&#123;value: msg.value&#125;(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Solidity极简入门-21-调用其他合约"><a href="#Solidity极简入门-21-调用其他合约" class="headerlink" title="Solidity极简入门: 21. 调用其他合约"></a>Solidity极简入门: 21. 调用其他合约</h1><h2 id="调用已部署合约"><a href="#调用已部署合约" class="headerlink" title="调用已部署合约"></a>调用已部署合约</h2><p>开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多<code>web3</code>项目依赖于调用其他合约，比如收益农场（<code>yield farming</code>）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。</p><h2 id="目标合约"><a href="#目标合约" class="headerlink" title="目标合约"></a>目标合约</h2><p>我们先写一个简单的合约<code>OtherContract</code>来调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约包含一个状态变量<code>_x</code>，一个事件<code>Log</code>在收到<code>ETH</code>时触发，三个函数：</p><ul><li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li><li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>_x</code>的值，并向合约发送<code>ETH</code>。</li><li><code>getX()</code>: 读取<code>_x</code>的值。</li></ul><h2 id="调用OtherContract合约"><a href="#调用OtherContract合约" class="headerlink" title="调用OtherContract合约"></a>调用<code>OtherContract</code>合约</h2><p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：<code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中<code>f()</code>是要调用的函数。</p><p>下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署<code>OtherContract</code>和<code>CallContract</code>：</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-1-9c522c370dfc53d1a0c273716f949c9e.png" alt="deploy contract0 in remix"></p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-2-a3c672e6dca937bf09dc3dfe5a421534.png" alt="deploy contract1 in remix"></p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-3-dd0cfc401d8462761c9b740ec21aa994.png" alt="deploy contract2 in remix"></p><h3 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1. 传入合约地址"></a>1. 传入合约地址</h3><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用<code>OtherContract</code>合约的<code>setX</code>函数为例，我们在新合约中写一个<code>callSetX</code>函数，传入已部署好的<code>OtherContract</code>合约地址<code>_Address</code>和<code>setX</code>的参数<code>x</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external&#123;</span><br><span class="line">    OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制<code>OtherContract</code>合约的地址，填入<code>callSetX</code>函数的参数中，成功调用后，调用<code>OtherContract</code>合约中的<code>getX</code>验证<code>x</code>变为123</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-4-89e705ffc18c8f90063c922e7504b31e.png" alt="call contract1 in remix"></p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-5-52866e87f467b4ebad52d6d00d4d2744.png" alt="call contract2 in remix"></p><h3 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2. 传入合约变量"></a>2. 传入合约变量</h3><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型改为目标合约名，比如<code>OtherContract</code>。下面例子实现了调用目标合约的<code>getX()</code>函数。</p><p><strong>注意</strong>该函数参数<code>OtherContract _Address</code>底层类型仍然是<code>address</code>，生成的<code>ABI</code>中、调用<code>callGetX</code>时传入的参数都是<code>address</code>类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">    x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX</code>函数的参数中，调用后成功获取<code>x</code>的值</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-6-615b6ab5f73c18a1c4a7a7d0be5f7228.png" alt="call contract3 in remix"></p><h3 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h3><p>我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量<code>oc</code>存储了<code>OtherContract</code>合约的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callGetX2(address _Address) external view returns(uint x)&#123;</span><br><span class="line">    OtherContract oc = OtherContract(_Address);</span><br><span class="line">    x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX2</code>函数的参数中，调用后成功获取<code>x</code>的值</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-7-ab9a5e3d84b27006392eb368b1e93d2d.png" alt="call contract4 in remix"></p><h3 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4. 调用合约并发送ETH"></a>4. 调用合约并发送<code>ETH</code></h3><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它来给合约转账：<code>_Name(_Address).f&#123;value: _Value&#125;()</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址，<code>f</code>是目标函数名，<code>_Value</code>是要转的<code>ETH</code>数额（以<code>wei</code>为单位）。</p><p><code>OtherContract</code>合约的<code>setX</code>函数是<code>payable</code>的，在下面这个例子中我们通过调用<code>setX</code>来往目标合约转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">    OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制<code>OtherContract</code>合约的地址，填入<code>setXTransferETH</code>函数的参数中，并转入10ETH</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-8-3566ee52a32b536dded77112c6599bdb.png" alt="call contract5 in remix"></p><p>转账后，我们可以通过<code>Log</code>事件和<code>getBalance()</code>函数观察目标合约<code>ETH</code>余额的变化。</p><p><img src="/2023/08/25/solidity%E8%BF%9B%E9%98%B619-21/21-9-d90c3bad37dd4d77acbd2ea8b695242e.png" alt="call contract6 in remix"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了如何通过目标合约代码（或接口）和地址来创建合约的引用，从而调用目标合约的函数。</p><h1 id="拓展知识：插槽冲突"><a href="#拓展知识：插槽冲突" class="headerlink" title="拓展知识：插槽冲突"></a>拓展知识：插槽冲突</h1><p>在计算机科学和软件开发中，“插槽冲突”这个术语可以有几个不同的含义，具体取决于其应用的上下文。以下是几个最常见的场景：</p><h3 id="1-哈希表中的插槽冲突"><a href="#1-哈希表中的插槽冲突" class="headerlink" title="1. 哈希表中的插槽冲突"></a>1. 哈希表中的插槽冲突</h3><p>在哈希表（或哈希映射）的实现中，插槽冲突（也称为哈希冲突）发生在两个不同的键通过哈希函数计算出相同的哈希值或索引时。当这种情况发生时，哈希表需要有一种机制来解决冲突，以确保所有的键都能被正确地存储和检索。常见的冲突解决技术包括：</p><ul><li><strong>开放寻址</strong>：如果一个插槽已被占用，哈希表将寻找下一个空闲的插槽。</li><li><strong>链表法</strong>：每个插槽存储一个链表，所有具有相同哈希值的元素都会被添加到这个链表中。</li></ul><h3 id="2-计算机网络中的插槽冲突"><a href="#2-计算机网络中的插槽冲突" class="headerlink" title="2. 计算机网络中的插槽冲突"></a>2. 计算机网络中的插槽冲突</h3><p>在计算机网络特别是使用时间分割多路访问（TDMA）协议的无线通信系统中，插槽冲突可能发生在多个设备尝试同时使用同一个时间插槽来传输数据时。这种冲突需要通过协调机制来避免或解决，例如使用冲突检测和冲突解决算法。</p><h3 id="3-Solidity智能合约中的存储插槽冲突"><a href="#3-Solidity智能合约中的存储插槽冲突" class="headerlink" title="3. Solidity智能合约中的存储插槽冲突"></a>3. Solidity智能合约中的存储插槽冲突</h3><p>在Solidity智能合约开发中，插槽冲突是一个特定于合约存储优化的问题。在Ethereum的智能合约中，存储是非常昂贵的资源，每个变量都被分配到一个称为“插槽”的位置。智能合约的变量如果不正确地排序，可能会导致不必要的存储空间浪费。在某些情况下，不同变量或继承的合约之间的不恰当交互也可能导致存储覆盖，这是一种严重的安全问题。</p><p>在设计和实现数据结构、通信协议或智能合约时，了解如何处理各种类型的插槽冲突是非常重要的，以确保系统的效率和安全性。如果你有一个特定的上下文或应用场景关于插槽冲突，提供更多的细节可以帮助我给出更具体的解释或解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础22-24</title>
      <link href="/2023/08/25/solidity%E8%BF%9B%E9%98%B622-24/"/>
      <url>/2023/08/25/solidity%E8%BF%9B%E9%98%B622-24/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-22-Call"><a href="#Solidity极简入门-22-Call" class="headerlink" title="Solidity极简入门: 22. Call"></a>Solidity极简入门: 22. Call</h1><p>我们曾在第20讲：发送ETH那一讲介绍过利用<code>call</code>来发送<code>ETH</code>，这一讲我们将介绍如何利用它调用合约。</p><p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p><ul><li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li><li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见第21讲：调用其他合约</li><li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li></ul><h3 id="call的使用规则"><a href="#call的使用规则" class="headerlink" title="call的使用规则"></a><code>call</code>的使用规则</h3><p><code>call</code>的使用规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call(二进制编码);</span><br></pre></td></tr></table></figure><p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><p>Copy</p><p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p><p>另外<code>call</code>在调用合约时可以指定交易发送的<code>ETH</code>数额和<code>gas</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(二进制编码);</span><br></pre></td></tr></table></figure><p>看起来有点复杂，下面我们举个<code>call</code>应用的例子。</p><h3 id="目标合约"><a href="#目标合约" class="headerlink" title="目标合约"></a>目标合约</h3><p>我们先写一个简单的目标合约<code>OtherContract</code>并部署，代码与第19讲中基本相同，只是多了<code>fallback</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约包含一个状态变量<code>x</code>，一个在收到<code>ETH</code>时触发的事件<code>Log</code>，三个函数：</p><ul><li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li><li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>x</code>的值，并向合约发送<code>ETH</code>。</li><li><code>getX()</code>: 读取<code>x</code>的值。</li></ul><h3 id="利用call调用目标合约"><a href="#利用call调用目标合约" class="headerlink" title="利用call调用目标合约"></a>利用<code>call</code>调用目标合约</h3><p><strong>1. Response事件</strong></p><p>我们写一个<code>Call</code>合约来调用目标合约函数。首先定义一个<code>Response</code>事件，输出<code>call</code>返回的<code>success</code>和<code>data</code>，方便我们观察返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure><p><strong>2. 调用setX函数</strong></p><p>我们定义<code>callSetX</code>函数来调用目标合约的<code>setX()</code>，转入<code>msg.value</code>数额的<code>ETH</code>，并释放<code>Response</code>事件输出<code>success</code>和<code>data</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">    // call setX()，同时可以发送ETH</span><br><span class="line">    (bool success, bytes memory data) = _addr.call&#123;value: msg.value&#125;(</span><br><span class="line">        abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们调用<code>callSetX</code>把状态变量<code>_x</code>改为5，参数为<code>OtherContract</code>地址和<code>5</code>，由于目标函数<code>setX()</code>没有返回值，因此<code>Response</code>事件输出的<code>data</code>为<code>0x</code>，也就是空。</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/22-1-c8df2a8eb61086564f7e7bd4346ae8a8.png" alt="22-1"></p><p><strong>3. 调用getX函数</strong></p><p>下面我们调用<code>getX()</code>函数，它将返回目标合约<code>_x</code>的值，类型为<code>uint256</code>。我们可以利用<code>abi.decode</code>来解码<code>call</code>的返回值<code>data</code>，并读出数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">    return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Response</code>事件的输出，我们可以看到<code>data</code>为<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>。而经过<code>abi.decode</code>，最终返回值为<code>5</code>。</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/22-2-008a7b4cdb2734426c2c284cfca79b41.png" alt="22-2"></p><p><strong>4. 调用不存在的函数</strong></p><p>如果我们给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<code>fallback</code>函数会被触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，我们<code>call</code>了不存在的<code>foo</code>函数。<code>call</code>仍能执行成功，并返回<code>success</code>，但其实调用的目标合约<code>fallback</code>函数。</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/22-3-b6b8e21fc3d39b5592c1a54f75fdad66.png" alt="22-3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了如何用<code>call</code>这一低级函数来调用其他合约。<code>call</code>不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和<code>ABI</code>的情况下调用目标合约，很有用。</p><h1 id="Solidity极简入门-23-Delegatecall"><a href="#Solidity极简入门-23-Delegatecall" class="headerlink" title="Solidity极简入门: 23. Delegatecall"></a>Solidity极简入门: 23. Delegatecall</h1><p><code>delegatecall</code>与<code>call</code>类似，是<code>solidity</code>中地址类型的低级成员函数。<code>delegate</code>中是委托&#x2F;代表的意思，那么<code>delegatecall</code>委托了什么？</p><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/VgMR533pA8WYtE5Lr65mQ.png" alt="call的语境"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/JucQiWVixdlmJl6zHjCSI.png" alt="delegatecall的语境"></p><p>大家可以这样理解：一个<code>富商</code>把它的资产（<code>状态变量</code>）都交给一个<code>VC</code>代理（<code>目标合约</code>的函数）来打理。执行的是<code>VC</code>的函数，但是改变的是<code>富商</code>的状态。</p><p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.delegatecall(二进制编码);</span><br></pre></td></tr></table></figure><p>Copy</p><p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><p>Copy</p><p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p><p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额</p><blockquote><p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p></blockquote><h2 id="什么情况下会用到delegatecall"><a href="#什么情况下会用到delegatecall" class="headerlink" title="什么情况下会用到delegatecall?"></a>什么情况下会用到<code>delegatecall</code>?</h2><p>目前<code>delegatecall</code>主要有两个应用场景：</p><ol><li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li></ol><h2 id="delegatecall例子"><a href="#delegatecall例子" class="headerlink" title="delegatecall例子"></a><code>delegatecall</code>例子</h2><p>调用结构：你（<code>A</code>）通过合约<code>B</code>调用目标合约<code>C</code>。</p><h3 id="被调用的合约C"><a href="#被调用的合约C" class="headerlink" title="被调用的合约C"></a>被调用的合约C</h3><p>我们先写一个简单的目标合约<code>C</code>：有两个<code>public</code>变量：<code>num</code>和<code>sender</code>，分别是<code>uint256</code>和<code>address</code>类型；有一个函数，可以将<code>num</code>设定为传入的<code>_num</code>，并且将<code>sender</code>设为<code>msg.sender</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发起调用的合约B"><a href="#发起调用的合约B" class="headerlink" title="发起调用的合约B"></a>发起调用的合约B</h3><p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure><p>接下来，我们分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别。</p><p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">    // call setVars()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h3><ol><li>首先，我们把合约<code>B</code>和<code>C</code>都部署好</li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-1-85c05f2d534e1a100a08f48bdea973b0.png" alt="deploy.png"></p><ol><li>部署之后，查看<code>C</code>合约状态变量的初始值，<code>B</code>合约的状态变量也是一样。</li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-2-0710e49786d637814b5998a6b2c33dc0.png" alt="initialstate.png"></p><ol><li>此时，调用合约<code>B</code>中的<code>callSetVars</code>，传入参数为合约<code>C</code>地址和<code>10</code></li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-3-24a8e170ef4ffc2ee1964ecea2e3fa46.png" alt="call.png"></p><ol><li>运行后，合约<code>C</code>中的状态变量将被修改：<code>num</code>被改为<code>10</code>，<code>sender</code>变为合约<code>B</code>的地址</li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-4-dc4ef0d4cdcdd6fa306fc19dd4b3f931.png" alt="resultcall.png"></p><ol><li>接下来，我们调用合约<code>B</code>中的<code>delegatecallSetVars</code>，传入参数为合约<code>C</code>地址和<code>100</code></li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-5-48ec2ddb52f11031a3d1fba839e74f26.png" alt="delegatecall.png"></p><ol><li>由于是<code>delegatecall</code>，语境为合约<code>B</code>。在运行后，合约<code>B</code>中的状态变量将被修改：<code>num</code>被改为<code>100</code>，<code>sender</code>变为你的钱包地址。合约<code>C</code>中的状态变量不会被修改。</li></ol><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/23-6-563be58ca9837183438ce89b76b618fb.png" alt="resultdelegatecall.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲我们介绍了<code>solidity</code>中的另一个低级函数<code>delegatecall</code>。与<code>call</code>类似，它可以用来调用其他合约；不同点在于运行的语境，<code>B call C</code>，语境为<code>C</code>；而<code>B delegatecall C</code>，语境为<code>B</code>。目前<code>delegatecall</code>最大的应用是代理合约和<code>EIP-2535 Diamonds</code>（钻石）。</p><h1 id="Solidity极简入门-24-在合约中创建新合约"><a href="#Solidity极简入门-24-在合约中创建新合约" class="headerlink" title="Solidity极简入门: 24. 在合约中创建新合约"></a>Solidity极简入门: 24. 在合约中创建新合约</h1><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。这一讲，我会用简化版的<code>uniswap</code>讲如何通过合约创建合约。</p><p>有两种方法可以在合约中创建新合约，<code>create</code>和<code>create2</code>，这里我们讲<code>create</code>，下一讲会介绍<code>create2</code>。</p><p><code>create</code>的用法很简单，就是<code>new</code>一个合约，并传入新合约构造函数所需的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p><h2 id="极简Uniswap"><a href="#极简Uniswap" class="headerlink" title="极简Uniswap"></a>极简Uniswap</h2><p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p><ol><li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li><li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li></ol><p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p><h3 id="Pair合约"><a href="#Pair合约" class="headerlink" title="Pair合约"></a><code>Pair</code>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><blockquote><p><strong>提问</strong>：为什么<code>uniswap</code>不在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好？</p><p><strong>答</strong>：因为<code>uniswap</code>使用的是<code>create2</code>创建合约，限制构造函数不能有参数。当使用<code>create</code>时，<code>Pair</code>合约允许构造函数有参数，可以在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好。</p></blockquote><h3 id="PairFactory"><a href="#PairFactory" class="headerlink" title="PairFactory"></a><code>PairFactory</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract PairFactory&#123;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">    address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">    function createPair(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">        // 创建新合约</span><br><span class="line">        Pair pair = new Pair(); </span><br><span class="line">        // 调用新合约的initialize方法</span><br><span class="line">        pair.initialize(tokenA, tokenB);</span><br><span class="line">        // 更新地址map</span><br><span class="line">        pairAddr = address(pair);</span><br><span class="line">        allPairs.push(pairAddr);</span><br><span class="line">        getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">        getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p><p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = new Pair(); </span><br></pre></td></tr></table></figure><p>就是创建合约的代码，非常简单。大家可以部署好<code>PairFactory</code>合约，然后用下面两个地址作为参数调用<code>createPair</code>，看看创建的币对地址是什么：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78</span><br><span class="line">BSC链上的PEOPLE地址:</span><br><span class="line">0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c</span><br></pre></td></tr></table></figure><h3 id="在remix上验证-1"><a href="#在remix上验证-1" class="headerlink" title="在remix上验证"></a>在remix上验证</h3><p>1.使用<code>WBNB</code>和<code>PEOPLE</code>的地址作为参数调用<code>createPair</code>,得到<code>Pair</code>合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/24-1-d4a6d130254e0486a4cb649b74cb40c4.png" alt="img"></p><p>2.查看<code>Pair</code>合约变量</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/24-2-3521680cc697424ef856eae959ad61c0.png" alt="img"></p><p>3.Debug查看<code>create</code>操作码</p><p><img src="/../../source/images/solidity%E8%BF%9B%E9%98%B622-24/24-3-f4526e2f8351ddfcabb223ec5ec6d20a.png" alt="img"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们用极简<code>Uniswap</code>的例子介绍了如何使用<code>create</code>方法再合约里创建合约，下一讲我们将介绍如何使用<code>create2</code>方法来实现极简<code>Uniswap</code>。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础13-15</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%8013-15/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%8013-15/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity极简入门-13-继承"><a href="#Solidity极简入门-13-继承" class="headerlink" title="Solidity极简入门: 13. 继承"></a>Solidity极简入门: 13. 继承</h1><p>这一讲，我们介绍<code>solidity</code>中的继承（<code>inheritance</code>），包括简单继承，多重继承，以及修饰器（<code>modifier</code>）和构造函数（<code>constructor</code>）的继承。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话，<code>solidity</code>也是面向对象的编程，也支持继承。</p><span id="more"></span><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li><li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li></ul><p><strong>注意</strong>：用<code>override</code>修饰<code>public</code>变量，会重写与变量同名的<code>getter</code>函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public override balanceOf;</span><br></pre></td></tr></table></figure><h3 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h3><p>我们先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>: <code>hip()</code>, <code>pop()</code>, <code>yeye()</code>，输出都是”Yeye”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Yeye &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    // 定义3个function: hip(), pop(), man()，Log值为Yeye。</span><br><span class="line">    function hip() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function yeye() public virtual &#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">    // 继承两个function: hip()和pop()，输出改为Baba。</span><br><span class="line">    function hip() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function baba() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><code>solidity</code>的合约可以继承多个合约。规则：</p><ol><li>继承时要按辈分最高到最低的顺序排。比如我们写一个<code>Erzi</code>合约，继承<code>Yeye</code>合约和<code>Baba</code>合约，那么就要写成<code>contract Erzi is Yeye, Baba</code>，而不能写成<code>contract Erzi is Baba, Yeye</code>，不然就会报错。</li><li>&#x3D;&#x3D;如果某一个函数在多个继承的合约里都存在，比如例子中的<code>hip()</code>和<code>pop()</code>，在子合约里必须重写，不然会报错。&#x3D;&#x3D;</li><li>重写在多个父合约中都重名的函数时，&#x3D;&#x3D;<code>override</code>关键字后面要加上所有父合约名字，例如<code>override(Yeye, Baba)</code>。&#x3D;&#x3D;</li></ol><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba&#123;</span><br><span class="line">    // 继承两个function: hip()和pop()，输出值为Erzi。</span><br><span class="line">    function hip() public virtual override(Yeye, Baba)&#123;</span><br><span class="line">        emit Log(&quot;Erzi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual override(Yeye, Baba) &#123;</span><br><span class="line">        emit Log(&quot;Erzi&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>Erzi</code>合约里面重写了<code>hip()</code>和<code>pop()</code>两个函数，将输出改为<code>”Erzi”</code>，并且还分别从<code>Yeye</code>和<code>Baba</code>合约继承了<code>yeye()</code>和<code>baba()</code>两个函数。</p><h3 id="修饰器的继承"><a href="#修饰器的继承" class="headerlink" title="修饰器的继承"></a>修饰器的继承</h3><p><code>Solidity</code>中的修饰器（<code>Modifier</code>）同样可以继承，用法与函数继承类似，在相应的地方加<code>virtual</code>和<code>override</code>关键字即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract Base1 &#123;</span><br><span class="line">    modifier exactDividedBy2And3(uint _a) virtual &#123;</span><br><span class="line">        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Identifier is Base1 &#123;</span><br><span class="line"></span><br><span class="line">    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数</span><br><span class="line">    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123;</span><br><span class="line">        return getExactDividedBy2And3WithoutModifier(_dividend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算一个数分别被2除和被3除的值</span><br><span class="line">    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123;</span><br><span class="line">        uint div2 = _dividend / 2;</span><br><span class="line">        uint div3 = _dividend / 3;</span><br><span class="line">        return (div2, div3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Identifier</code>合约可以直接在代码中使用父合约中的<code>exactDividedBy2And3</code>修饰器，也可以利用<code>override</code>关键字重写修饰器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier exactDividedBy2And3(uint _a) override &#123;</span><br><span class="line">    _;</span><br><span class="line">    require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约<code>A</code>里面有一个状态变量<code>a</code>，并由构造函数的参数来确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数的继承</span><br><span class="line">abstract contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line"></span><br><span class="line">    constructor(uint _a) &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在继承时声明父构造函数的参数，例如：<code>contract B is A(1)</code></li><li>在子合约的构造函数中声明构造函数的参数，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用父合约的函数"><a href="#调用父合约的函数" class="headerlink" title="调用父合约的函数"></a>调用父合约的函数</h3><p>子合约有两种方式调用父合约的函数，直接调用和利用<code>super</code>关键字。</p><ol><li>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">    Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>solidity</code>继承关系按声明时从右到左的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是最近的父合约，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">    // 将调用最近的父合约函数，Baba.pop()</span><br><span class="line">    super.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h3><p>在面向对象编程中，钻石继承（菱形继承）指一个派生类同时有两个或两个以上的基类。</p><p>&#x3D;&#x3D;在多重+菱形继承链条上使用<code>super</code>关键字时，需要注意的是使用<code>super</code>会调用继承链条上的每一个合约的相关函数，而不是只调用最近的父合约。&#x3D;&#x3D;</p><p>我们先写一个合约<code>God</code>，再写<code>Adam</code>和<code>Eve</code>两个合约继承<code>God</code>合约，最后让创建合约<code>people</code>继承自<code>Adam</code>和<code>Eve</code>，每个合约都有<code>foo</code>和<code>bar</code>两个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">/* 继承树：</span><br><span class="line">  God</span><br><span class="line"> /  \</span><br><span class="line">Adam Eve</span><br><span class="line"> \  /</span><br><span class="line">people</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract God &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    function foo() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.foo called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.bar called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Adam is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.foo called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Eve is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.foo called&quot;);</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract people is Adam, Eve &#123;</span><br><span class="line">    function foo() public override(Adam, Eve) &#123;</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public override(Adam, Eve) &#123;</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，调用合约<code>people</code>中的<code>super.bar()</code>会依次调用<code>Eve</code>、<code>Adam</code>，最后是<code>God</code>合约。</p><p>虽然<code>Eve</code>、<code>Adam</code>都是<code>God</code>的子合约，但整个过程中<code>God</code>合约只会被调用一次。原因是Solidity借鉴了Python的方式，强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序。更多细节你可以查阅<a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html?highlight=%E7%BB%A7%E6%89%BF#index-16">Solidity的官方文档</a>。</p><h2 id="在Remix上验证"><a href="#在Remix上验证" class="headerlink" title="在Remix上验证"></a>在Remix上验证</h2><ul><li><p>合约简单继承示例, 可以观察到Baba合约多了Yeye的函数</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-1-42f0a6c7cc188762c41239403eb84e8b.png" alt="13-1"></p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-2-9c0be37c4fab16f90c39580cbbead5ed.png" alt="13-2"></p></li><li><p>合约多重继承可以参考简单继承的操作步骤来增加部署Erzi合约，然后观察暴露的函数以及尝试调用来查看日志</p></li><li><p>修饰器继承示例</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-3-7fb3ed386135bd918b84cd92949884a4.png" alt="13-3"></p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-4-c578cff17c65f768d1505da77c3cac0c.png" alt="13-4"></p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-5-58a3d5a358dbda0ffb40afb626801005.png" alt="13-5"></p></li><li><p>构造函数继承示例</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-6-099cd67439dcb0194684557cc1e29289.png" alt="13-6"></p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-7-2c772dcd6711e67afd51118ae7ded35e.png" alt="13-7"></p></li><li><p>调用父合约示例</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-8-dcc83777980c789aec12ff8467b8d51f.png" alt="13-8"></p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-9-49f35bff8cf0343cbbce2dd8fe9d3c59.png" alt="13-9"></p></li><li><p>菱形继承示例</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/13-10-3e690c6705a19b1e5b7d43a0570f5d0e.png" alt="13-10"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了<code>solidity</code>继承的基本用法，包括简单继承，多重继承，修饰器和构造函数的继承、调用父合约中的函数，以及多重继承中的菱形继承问题。</p><h1 id="Solidity极简入门-14-抽象合约和接口"><a href="#Solidity极简入门-14-抽象合约和接口" class="headerlink" title="Solidity极简入门: 14. 抽象合约和接口"></a>Solidity极简入门: 14. 抽象合约和接口</h1><p>这一讲，我们用<code>ERC721</code>的接口合约为例介绍<code>solidity</code>中的抽象合约（<code>abstract</code>）和接口（<code>interface</code>），帮助大家更好的理解<code>ERC721</code>标准。</p><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>&#123;&#125;</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。拿我们之前的<a href="https://github.com/AmazingAng/WTFSolidity/tree/main/07_InsertionSort">插入排序合约</a>为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract contract InsertionSort&#123;</span><br><span class="line">    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类似于抽象合约，但它不实现任何功能。接口的规则：</p><ol><li>不能包含状态变量</li><li>不能包含构造函数</li><li>不能继承除接口外的其他合约</li><li>所有函数都必须是external且不能有函数体</li><li>继承接口的合约必须实现接口定义的所有功能</li></ol><p>虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如<code>ERC20</code>或<code>ERC721</code>），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：</p><ol><li>合约里每个函数的<code>bytes4</code>选择器，以及函数签名<code>函数名(每个参数类型）</code>。</li><li>接口id（更多信息见<a href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li></ol><p>另外，接口与合约<code>ABI</code>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p><p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以<code>;</code>代替函数体<code>&#123; &#125;</code>结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span><br><span class="line">    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span><br><span class="line">    </span><br><span class="line">    function balanceOf(address owner) external view returns (uint256 balance);</span><br><span class="line"></span><br><span class="line">    function ownerOf(uint256 tokenId) external view returns (address owner);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function approve(address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function getApproved(uint256 tokenId) external view returns (address operator);</span><br><span class="line"></span><br><span class="line">    function setApprovalForAll(address operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address owner, address operator) external view returns (bool);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IERC721事件"><a href="#IERC721事件" class="headerlink" title="IERC721事件"></a>IERC721事件</h3><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p><ul><li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li><li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li><li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li></ul><h3 id="IERC721函数"><a href="#IERC721函数" class="headerlink" title="IERC721函数"></a>IERC721函数</h3><ul><li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li><li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li><li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li><li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li><li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li><li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li><li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li></ul><h3 id="什么时候使用接口？"><a href="#什么时候使用接口？" class="headerlink" title="什么时候使用接口？"></a>什么时候使用接口？</h3><p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p><p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract interactBAYC &#123;</span><br><span class="line">    // 利用BAYC地址创建接口合约变量（ETH主网）</span><br><span class="line">    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);</span><br><span class="line"></span><br><span class="line">    // 通过接口调用BAYC的balanceOf()查询持仓量</span><br><span class="line">    function balanceOfBAYC(address owner) external view returns (uint256 balance)&#123;</span><br><span class="line">        return BAYC.balanceOf(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过接口调用BAYC的safeTransferFrom()安全转账</span><br><span class="line">    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external&#123;</span><br><span class="line">        BAYC.safeTransferFrom(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Remix上验证-1"><a href="#在Remix上验证-1" class="headerlink" title="在Remix上验证"></a>在Remix上验证</h2><ul><li><p>抽象合约示例（简单的演示代码如图所示）</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/14-1-044a8470458eea92577e72cdbdd8dd24.png" alt="14-1"></p></li><li><p>接口示例（简单的演示代码如图所示）</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/14-2-f9d96ce31ea1e53ff8631a02022a2929.png" alt="14-2"></p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我介绍了<code>solidity</code>中的抽象合约（<code>abstract</code>）和接口（<code>interface</code>），他们都可以写模版并且减少代码冗余。我们还讲了<code>ERC721</code>接口合约<code>IERC721</code>，以及如何利用它与无聊猿<code>BAYC</code>合约进行交互</p><h1 id="Solidity极简入门-15-异常"><a href="#Solidity极简入门-15-异常" class="headerlink" title="Solidity极简入门: 15. 异常"></a>Solidity极简入门: 15. 异常</h1><p>这一讲，我们介绍<code>solidity</code>三种抛出异常的方法：<code>error</code>，<code>require</code>和<code>assert</code>，并比较三种方法的<code>gas</code>消耗。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>写智能合约经常会出<code>bug</code>，<code>solidity</code>中的异常命令帮助我们<code>debug</code>。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>error</code>是<code>solidity 0.8.4版本</code>新加的内容，方便且高效（省<code>gas</code>）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数，帮助开发者更好地调试。人们可以在<code>contract</code>之外定义异常。下面，我们定义一个<code>TransferNotOwner</code>异常，当用户不是代币<code>owner</code>的时候尝试转账，会抛出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(); // 自定义error</span><br></pre></td></tr></table></figure><p>我们也可以定义一个携带参数的异常，来提示尝试转账的账户地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TransferNotOwner(address sender); // 自定义的带参数的error</span><br></pre></td></tr></table></figure><p>在执行当中，<code>error</code>必须搭配<code>revert</code>（回退）命令使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function transferOwner1(uint256 tokenId, address newOwner) public &#123;</span><br><span class="line">    if(_owners[tokenId] != msg.sender)&#123;</span><br><span class="line">        revert TransferNotOwner();</span><br><span class="line">        // revert TransferNotOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">    _owners[tokenId] = newOwner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>transferOwner1()</code>函数，它会检查代币的<code>owner</code>是不是发起人，如果不是，就会抛出<code>TransferNotOwner</code>异常；如果是的话，就会转账。</p><h3 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h3><p><code>require</code>命令是<code>solidity 0.8版本</code>之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是<code>gas</code>随着描述异常的字符串长度增加，比<code>error</code>命令要高。使用方法：<code>require(检查条件，&quot;异常的描述&quot;)</code>，当检查条件不成立的时候，就会抛出异常。</p><p>我们用<code>require</code>命令重写一下上面的<code>transferOwner</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transferOwner2(uint256 tokenId, address newOwner) public &#123;</span><br><span class="line">    require(_owners[tokenId] == msg.sender, &quot;Transfer Not Owner&quot;);</span><br><span class="line">    _owners[tokenId] = newOwner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p><code>assert</code>命令一般用于程序员写程序<code>debug</code>，因为它不能解释抛出异常的原因（比<code>require</code>少个字符串）。它的用法很简单，<code>assert(检查条件）</code>，当检查条件不成立的时候，就会抛出异常。</p><p>我们用<code>assert</code>命令重写一下上面的<code>transferOwner</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transferOwner3(uint256 tokenId, address newOwner) public &#123;</span><br><span class="line">    assert(_owners[tokenId] == msg.sender);</span><br><span class="line">    _owners[tokenId] = newOwner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ol><li><p>输入任意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256</span><br></pre></td></tr></table></figure><p>数字和非0地址，调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferOwner1</span><br></pre></td></tr></table></figure><p>，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure><p>方法，控制台抛出了异常并显示我们自定义的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransferNotOwner</span><br></pre></td></tr></table></figure><p>。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/15-1-108068d779547bb5f2bbe63c4e350fab.png" alt="15 1.png"></p></li><li><p>输入任意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256</span><br></pre></td></tr></table></figure><p>数字和非0地址，调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferOwner2</span><br></pre></td></tr></table></figure><p>，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require</span><br></pre></td></tr></table></figure><p>方法，控制台抛出了异常并打印出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require</span><br></pre></td></tr></table></figure><p>中的字符串。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/15-2-5cd86c90ad4a466946c842c346a5ee18.png" alt="15 2.png"></p></li><li><p>输入任意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint256</span><br></pre></td></tr></table></figure><p>数字和非0地址，调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferOwner3</span><br></pre></td></tr></table></figure><p>，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert</span><br></pre></td></tr></table></figure><p>方法，控制台只抛出了异常。</p><p><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%8013-15/15-3-390b3562e3410dd9f6256b66e8d2610f.png" alt="15 3.png"></p></li></ol><h2 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h2><p>我们比较一下三种抛出异常的<code>gas</code>消耗，通过remix控制台的Debug按钮，能查到每次函数调用的<code>gas</code>消耗分别如下： （使用0.8.17版本编译）</p><ol><li><strong><code>error</code>方法<code>gas</code>消耗</strong>：24457 (<strong>加入参数后<code>gas</code>消耗</strong>：24660)</li><li><strong><code>require</code>方法<code>gas</code>消耗</strong>：24755</li><li><strong><code>assert</code>方法<code>gas</code>消耗</strong>：24473</li></ol><p>我们可以看到，<code>error</code>方法<code>gas</code>最少，其次是<code>assert</code>，<code>require</code>方法消耗<code>gas</code>最多！因此，<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>，大家要多用！（注意，由于部署测试时间的不同，每个函数的<code>gas</code>消耗会有所不同，但是比较结果会是一致的。）</p><p><strong>备注:</strong> Solidity 0.8.0之前的版本，<code>assert</code>抛出的是一个 <code>panic exception</code>，会把剩余的 <code>gas</code> 全部消耗，不会返还。更多细节见<a href="https://docs.soliditylang.org/en/v0.8.17/control-structures.html">官方文档</a>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍<code>solidity</code>三种抛出异常的方法：<code>error</code>，<code>require</code>和<code>assert</code>，并比较了三种方法的<code>gas</code>消耗。结论：<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity基础1-3</title>
      <link href="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/"/>
      <url>/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Solidity-简介"><a href="#Solidity-简介" class="headerlink" title="Solidity 简介"></a>Solidity 简介</h2><p><code>Solidity</code> 是一种用于编写以太坊虚拟机（<code>EVM</code>）智能合约的编程语言。我认为掌握 <code>Solidity</code> 是参与链上项目的必备技能：区块链项目大部分是开源的，如果你能读懂代码，就可以规避很多亏钱项目。</p><p><code>Solidity</code> 具有两个特点：</p><ol><li>“基于对象”：学会 <code>Solidity</code> 之后，可以助你在区块链领域找到好工作，挣钱找对象。</li><li>“高级”：不会 <code>Solidity</code>，在币圈会显得很 low。</li></ol> <span id="more"></span><h2 id="开发工具：Remix"><a href="#开发工具：Remix" class="headerlink" title="开发工具：Remix"></a>开发工具：Remix</h2><p>本教程中，我们将使用 <code>Remix</code> 运行 <code>Solidity</code> 合约。<code>Remix</code> 是以太坊官方推荐的智能合约集成开发环境（IDE），适合新手，可以在浏览器中快速开发和部署合约，无需在本地安装任何程序。</p><p>网址：<a href="https://remix.ethereum.org/">https://remix.ethereum.org</a></p><p>在 <code>Remix</code> 中，左侧菜单有三个按钮，分别对应文件（编写代码）、编译（运行代码）和部署（将合约部署到链上）。点击“创建新文件”（<code>Create New File</code>）按钮，即可创建一个空白的 <code>Solidity</code> 合约。</p><p><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-1.png" alt="Remix 面板"></p><h2 id="第一个-Solidity-程序"><a href="#第一个-Solidity-程序" class="headerlink" title="第一个 Solidity 程序"></a>第一个 Solidity 程序</h2><p>这个简单的程序只有 1 行注释和 3 行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract HelloWeb3&#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拆解程序，学习 Solidity 代码源文件的结构：</p><ol><li><p>第 1 行是注释，说明代码所使用的软件许可（license），这里使用的是 MIT 许可。如果不写许可，编译时会出现警告（warning），但程序仍可运行。Solidity 注释以“&#x2F;&#x2F;”开头，后面跟注释内容，注释不会被程序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br></pre></td></tr></table></figure></li><li><p>第 2 行声明源文件所使用的 Solidity 版本，因为不同版本的语法有差异。这行代码表示源文件将不允许小于 0.8.21 版本或大于等于 0.9.0 的编译器编译（第二个条件由 <code>^</code> 提供）。Solidity 语句以分号（;）结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.21;</span><br></pre></td></tr></table></figure></li><li><p>第 3-4 行是合约部分。第 3 行创建合约（contract），并声明合约名为 <code>HelloWeb3</code>。第 4 行是合约内容，声明了一个 string（字符串）变量 <code>_string</code>，并赋值为 “Hello Web3!”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWeb3 &#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>后续我们会更详细地介绍 Solidity 中的变量。</p><h2 id="编译并部署代码"><a href="#编译并部署代码" class="headerlink" title="编译并部署代码"></a>编译并部署代码</h2><p>在 Remix 编辑代码的页面，按 Ctrl + S 即可编译代码，非常方便。</p><p>编译完成后，点击左侧菜单的“部署”按钮，进入部署页面。</p><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-2.png" alt="Deploy配图"></p><p>默认情况下，<code>Remix</code> 会使用 <code>Remix</code> 虚拟机（以前称为 JavaScript 虚拟机）来模拟以太坊链，运行智能合约，类似在浏览器里运行一条测试链。<code>Remix</code> 还会为你分配一些测试账户，每个账户里有 100 ETH（测试代币），随意使用。点击 <code>Deploy</code>（黄色按钮），即可部署我们编写的合约。</p><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/1-3.png" alt="_string配图"></p><p>部署成功后，在下方会看到名为 <code>HelloWeb3</code> 的合约。点击 <code>_string</code>，即可看到 “Hello Web3!”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节课程中，我们简要介绍了 <code>Solidity</code> 和 <code>Remix</code> 工具，并完成了第一个 <code>Solidity</code> 程序 —— <code>HelloWeb3</code>。接下来，我们将继续深入学习 <code>Solidity</code>！</p><h3 id="中文-Solidity-资料推荐"><a href="#中文-Solidity-资料推荐" class="headerlink" title="中文 Solidity 资料推荐"></a>中文 Solidity 资料推荐</h3><ol><li><a href="https://docs.soliditylang.org/zh/v0.8.19/index.html">Solidity中文文档</a>（官方文档的中文翻译）</li><li><a href="https://space.bilibili.com/286084162">崔棉大师solidity教程</a> web3技术教学博主，我看他视频学到了很多</li></ol><h1 id="WTF-Solidity极简入门-2-值类型"><a href="#WTF-Solidity极简入门-2-值类型" class="headerlink" title="WTF Solidity极简入门: 2. 值类型"></a>WTF Solidity极简入门: 2. 值类型</h1><h2 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h2><p>&#x3D;&#x3D;主要就是这3种类型&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>引用类型(Reference Type)<strong>：包括</strong>数组</strong>和<strong>结构体</strong>，这类变量占空间大，赋值时候<strong>直接传递地址</strong>（类似指针）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>映射类型(Mapping Type)</strong>: Solidity中存储<strong>键值对</strong>的数据结构，可以理解为哈希表&#x3D;&#x3D;</li><li>函数类型(Function Types) : 代表函数的变量</li></ol><p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 布尔值</span><br><span class="line">bool public _bool = true;</span><br></pre></td></tr></table></figure><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 布尔运算</span><br><span class="line">bool public _bool1 = !_bool; // 取非</span><br><span class="line">bool public _bool2 = _bool &amp;&amp; _bool1; // 与</span><br><span class="line">bool public _bool3 = _bool || _bool1; // 或</span><br><span class="line">bool public _bool4 = _bool == _bool1; // 相等</span><br><span class="line">bool public _bool5 = _bool != _bool1; // 不相等</span><br></pre></td></tr></table></figure><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 整型</span><br><span class="line">int public _int = -1; // 整数，包括负数</span><br><span class="line">uint public _uint = 1; // 正整数</span><br><span class="line">uint256 public _number = 20220330; // 256位正整数</span><br></pre></td></tr></table></figure><p>常用的整型运算符包括：</p><ul><li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li><li>算数运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 整数运算</span><br><span class="line">uint256 public _number1 = _number + 1; // +，-，*，/</span><br><span class="line">uint256 public _number2 = 2**2; // 指数</span><br><span class="line">uint256 public _number3 = 7 % 2; // 取余数</span><br><span class="line">bool public _numberbool = _number2 &gt; _number3; // 比大小</span><br></pre></td></tr></table></figure><p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p><h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型(address)有两类：</p><ul><li>&#x3D;&#x3D;普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;payable address: 比普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员方法，用于接收转账。&#x3D;&#x3D;</li></ul><p>我们会在之后的章节更加详细地介绍 payable address。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 地址</span><br><span class="line">address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;</span><br><span class="line">address payable public _address1 = payable(_address); // payable address，可以转账、查余额</span><br><span class="line">// 地址类型的成员</span><br><span class="line">uint256 public balance = _address1.balance; // balance of address</span><br></pre></td></tr></table></figure><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>&#x3D;&#x3D;字节数组分为定长和不定长两种：&#x3D;&#x3D;</p><ul><li>&#x3D;&#x3D;定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组<strong>最多存储 32 bytes</strong> 数据，即<code>bytes32</code>。&#x3D;&#x3D;</li><li>不定长字节数组: 属于&#x3D;&#x3D;引用类型&#x3D;&#x3D;（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度的字节数组</span><br><span class="line">bytes32 public _byte32 = &quot;MiniSolidity&quot;; </span><br><span class="line">bytes1 public _byte = _byte32[0]; </span><br></pre></td></tr></table></figure><p>在上述代码中，<code>MiniSolidity</code> 变量以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p><p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p><p>&#x3D;&#x3D;表示一个16进制需要4位，一个bytes1是8位，所以一个bytes1可以表示2个16进制位&#x3D;&#x3D;</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用enum将uint 0， 1， 2表示为Buy, Hold, Sell</span><br><span class="line">enum ActionSet &#123; Buy, Hold, Sell &#125;</span><br><span class="line">// 创建enum变量 action</span><br><span class="line">ActionSet action = ActionSet.Buy;</span><br></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的正整数是否在枚举的长度内，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// enum可以和uint显式的转换</span><br><span class="line">function enumToUint() external view returns(uint)&#123;</span><br><span class="line">    return uint(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enum</code> 是一个比较冷门的变量，几乎没什么人用。</p><h2 id="在-Remix-上运行"><a href="#在-Remix-上运行" class="headerlink" title="在 Remix 上运行"></a>在 Remix 上运行</h2><ul><li>部署合约后可以查看每个类型的变量的数值：</li></ul><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/2-1.png" alt="2-1.png"></p><ul><li><code>enum</code> 和 <code>uint</code> 转换的示例：</li></ul><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/02_ValueTypes/img/2-2.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/2-2.png" alt="2-2.png"></a> </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 Solidity 中值类型，包括布尔型、整型、地址、定长字节数组和枚举。在后续章节，我们将继续介绍 Solidity 的其他变量类型，包括引用类型和映射类型。</p><h1 id="Solidity极简入门-3-函数类型"><a href="#Solidity极简入门-3-函数类型" class="headerlink" title="Solidity极简入门: 3. 函数类型"></a>Solidity极简入门: 3. 函数类型</h1><p>solidity官方文档里把函数归到数值类型，但我觉得差别很大，所以单独分一类。我们先看一下solidity中函数的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function &lt;function name&gt;(&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><p>Copy</p><p>看着些复杂，咱们从前往后一个一个看（方括号中的是可写可不写的关键字）：</p><ol><li><p><code>function</code>：声明函数时的固定用法，想写函数，就要以function关键字开头。</p></li><li><p><code>&lt;function name&gt;</code>：函数名。</p></li><li><p><code>(&lt;parameter types&gt;)</code>：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。</p></li><li><p><code>&#123;internal|external|public|private&#125;</code>：&#x3D;&#x3D;函数可见性说明符&#x3D;&#x3D;，一共4种。没标明函数类型的，&#x3D;&#x3D;默认&#x3D;&#x3D;<code>public</code>。合约之外的函数，即”自由函数”，始终具有隐含<code>internal</code>可见性。</p><ul><li><code>public</code>: 内部外部均可见。</li><li><code>private</code>: 只能从本合约内部访问，继承的合约也不能用。</li><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 &#x3D;&#x3D;这里this后文有解释&#x3D;&#x3D;</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><p><strong>Note 1</strong>: 没有标明可见性类型的函数，默认为<code>public</code>。</p><p><strong>Note 2</strong>: <code>public|private|internal</code> 也可用于&#x3D;&#x3D;修饰状态变量&#x3D;&#x3D;。 &#x3D;&#x3D;<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。&#x3D;&#x3D;</p><p><strong>Note 3</strong>: 没有标明可见性类型的&#x3D;&#x3D;状态变量，默认为<code>internal</code>。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;注意这里状态变量和函数可见性的不一样，默认为只能从合约内部访问&#x3D;&#x3D;</p></li><li><p><code>[pure|view|payable]</code>：&#x3D;&#x3D;决定函数权限&#x2F;功能的关键字&#x3D;&#x3D;。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入<code>ETH</code>。<code>pure</code>和<code>view</code>的介绍见下一节。</p></li></ol><p>&#x3D;&#x3D;如果没有写这三个关键字就是可读可写&#x3D;&#x3D;</p><ol><li><code>[returns ()]</code>：函数返回的变量类型和名称。</li></ol><h2 id="到底什么是Pure和View"><a href="#到底什么是Pure和View" class="headerlink" title="到底什么是Pure和View"></a>到底什么是<code>Pure</code>和<code>View</code></h2><p>我刚开始学<code>solidity</code>的时候，一直不理解<code>pure</code>跟<code>view</code>关键字，因为别的语言没有类似的关键字。<code>solidity</code>加入这两个关键字，我认为是因为<code>gas fee</code>。合约的状态变量存储在链上，<code>gas fee</code>很贵，如果不改变链上状态，就不用付<code>gas</code>。包含<code>pure</code>跟<code>view</code>关键字的函数是&#x3D;&#x3D;<strong>不改写链上状态的</strong>&#x3D;&#x3D;，因此用户直接调用他们是不需要付gas的（合约中非<code>pure</code>&#x2F;<code>view</code>函数调用它们则会改写链上状态，需要付gas）。</p><p>&#x3D;&#x3D;这里可太重要了&#x3D;&#x3D;</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用<code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记<code>view</code>或<code>pure</code>的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><p>我画了一个马里奥插画，帮助大家理解。在插画里，我把合约中的状态变量（存储在链上）比作碧池公主，三种不同的角色代表不同的关键字。</p><p><a href="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538"><img src="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538" alt="WTF is pure and view in solidity?"></a></p><ul><li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数<strong>既不能读取也不能写入链上的状态变量</strong>。就像小怪一样，看不到也摸不到碧琪公主。</li><li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li><li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-pure-和-view"><a href="#1-pure-和-view" class="headerlink" title="1. pure 和 view"></a>1. pure 和 view</h3><p>我们在合约里定义一个状态变量 <code>number</code>，初始化为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract FunctionTypes&#123;</span><br><span class="line">    uint256 public number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>add()</code> 函数，每次调用会让 <code>number</code> 增加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 默认function</span><br><span class="line">function add() external&#123;</span><br><span class="line">    number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>add()</code> 函数被标记为 <code>pure</code>，比如 <code>function add() external pure</code>，就会报错。因为 <code>pure</code> 是不配读取合约里的状态变量的，更不配改写。那 <code>pure</code> 函数能做些什么？举个例子，你可以给函数传递一个参数 <code>_number</code>，然后让他返回 <code>_number + 1</code>，这个操作不会读取或写入状态变量。</p><p>&#x3D;&#x3D;我的理解就是，参数或者函数内部定义的变量都不是状态变量，函数结束了，这些变量就消失了，也不上链&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pure: 纯纯牛马</span><br><span class="line">function addPure(uint256 _number) external pure returns(uint256 new_number)&#123;</span><br><span class="line">    new_number = _number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-3.png" alt="3-3.png"></p><p>如果 <code>add()</code> 函数被标记为 <code>view</code>，比如 <code>function add() external view</code>，也会报错。因为 <code>view</code> 能读取，但不能够改写状态变量。我们可以稍微改写下函数，读取但是不改写 <code>number</code>，返回一个新的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// view: 看客</span><br><span class="line">function addView() external view returns(uint256 new_number) &#123;</span><br><span class="line">    new_number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-4.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-4.png" alt="3-4.png"></a></p><p>&#x3D;&#x3D;重点来了，view和pure的区别就是view可以读取状态变量，pure不可以读取状态变量，他的输出只能由参数决定。&#x3D;&#x3D;</p><h3 id="2-internal-v-s-external"><a href="#2-internal-v-s-external" class="headerlink" title="2. internal v.s. external"></a>2. internal v.s. external</h3><ul><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// internal: 内部函数</span><br><span class="line">function minus() internal &#123;</span><br><span class="line">    number = number - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约内的函数可以调用内部函数</span><br><span class="line">function minusCall() external &#123;</span><br><span class="line">    minus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;重点来了，也就是带有函数可见性说明符internal的，在部署完之后，不可以调用，因为我们部署完合约之后，在remix里面进行函数调用，查看变量，传参都相当于在合约外部调用，所以想要调用带有internal的函数，只能通过另外一个external函数调用&#x3D;&#x3D;</p><p>我们定义一个 <code>internal</code> 的 <code>minus()</code> 函数，每次调用使得 <code>number</code> 变量减少 1。由于 <code>internal</code> 函数只能由合约内部调用，我们必须再定义一个 <code>external</code> 的 <code>minusCall()</code> 函数，通过它间接调用内部的 <code>minus()</code> 函数。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-1.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-1.png" alt="3-1.png"></a></p><h3 id="3-payable"><a href="#3-payable" class="headerlink" title="3. payable"></a>3. payable</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// payable: 递钱，能给合约支付eth的函数</span><br><span class="line">function minusPayable() external payable returns(uint256 balance) &#123;</span><br><span class="line">    minus();    </span><br><span class="line">    balance = address(this).balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>external payable</code> 的 <code>minusPayable()</code> 函数，间接的调用 <code>minus()</code>，并且返回合约里的 ETH 余额（<code>this</code> 关键字可以让我们引用合约地址）。我们可以在调用 <code>minusPayable()</code> 时往合约里转入1个 ETH。</p><p>&#x3D;&#x3D;<code>this</code>关键字代表合约自身的地址。<code>address(this).balance</code>会返回当前合约地址所持有的以太币（ETH）数量，以wei为单位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>关键字代表当前合约的实例。它允许你在合约内部访问合约自身的成员，比如函数和状态变量。<code>this</code>可以在合约的任何函数内使用，但通常在需要引用合约自身的上下文中使用，比如转账操作时指向合约自己的地址（<code>address(this)</code>）。这使得合约能够操作自己的属性和调用自己的方法。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>除了用于引用合约自身的实例和获取合约的地址外（<code>address(this)</code>），还可以用来在合约内部调用当前合约的其他公共和外部函数。例如，如果你有一个公共函数<code>functionA</code>，你可以通过<code>this.functionA()</code>来调用它，尤其在需要显式地表明函数调用是在合约内部发生时。这种方式通常用于需要通过合约地址调用函数的场景，确保调用遵循EVM的调用规则，如通过消息调用（message call）。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;一言以蔽之：在合约内部使用<code>this</code>调用函数，实际上是模拟外部调用者的行为。&#x3D;&#x3D;</p><p><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    uint256 public myNumber;</span><br><span class="line"></span><br><span class="line">    function setMyNumber(uint256 _myNumber) external &#123;</span><br><span class="line">        myNumber = _myNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateMyNumber(uint256 _newNumber) public &#123;</span><br><span class="line">        // 使用this关键字调用当前合约的另一个函数(external) 必须使用this</span><br><span class="line">        this.setMyNumber(_newNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838"><img src="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838" alt="mirror-image-1"></a></p><p>我们可以在返回的信息中看到，合约的余额变为 1 ETH。</p><p><a href="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330"><img src="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330" alt="mirror-image-2"></a></p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-2.png"><img src="/2023/08/25/solidity%E5%9F%BA%E7%A1%801-3/3-2.png" alt="3-2.png"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 <code>Solidity</code> 中的函数。<code>pure</code> 和 <code>view</code> 关键字比较难理解，在其他语言中没出现过：<code>view</code> 函数可以读取状态变量，但不能改写；<code>pure</code> 函数既不能读取也不能改写状态变量。</p>]]></content>
      
      
      <categories>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
