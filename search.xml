<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/04/18/solidity%E5%9F%BA%E7%A1%801-3/"/>
      <url>/2024/04/18/solidity%E5%9F%BA%E7%A1%801-3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: solidity基础1-3</span><br><span class="line">tags: [solidity基础]</span><br><span class="line">categories: [solidity]</span><br><span class="line">date: 2023-8-25 18:03:07</span><br></pre></td></tr></table></figure><h2 id="Solidity-简介"><a href="#Solidity-简介" class="headerlink" title="Solidity 简介"></a>Solidity 简介</h2><p><code>Solidity</code> 是一种用于编写以太坊虚拟机（<code>EVM</code>）智能合约的编程语言。我认为掌握 <code>Solidity</code> 是参与链上项目的必备技能：区块链项目大部分是开源的，如果你能读懂代码，就可以规避很多亏钱项目。</p><p><code>Solidity</code> 具有两个特点：</p><ol><li>“基于对象”：学会 <code>Solidity</code> 之后，可以助你在区块链领域找到好工作，挣钱找对象。</li><li>“高级”：不会 <code>Solidity</code>，在币圈会显得很 low。</li></ol><h2 id="开发工具：Remix"><a href="#开发工具：Remix" class="headerlink" title="开发工具：Remix"></a>开发工具：Remix</h2><p>本教程中，我们将使用 <code>Remix</code> 运行 <code>Solidity</code> 合约。<code>Remix</code> 是以太坊官方推荐的智能合约集成开发环境（IDE），适合新手，可以在浏览器中快速开发和部署合约，无需在本地安装任何程序。</p><p>网址：<a href="https://remix.ethereum.org/">https://remix.ethereum.org</a></p><p>在 <code>Remix</code> 中，左侧菜单有三个按钮，分别对应文件（编写代码）、编译（运行代码）和部署（将合约部署到链上）。点击“创建新文件”（<code>Create New File</code>）按钮，即可创建一个空白的 <code>Solidity</code> 合约。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/01_HelloWeb3/img/1-1.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/1-1.png" alt="Remix 面板"></a></p><h2 id="第一个-Solidity-程序"><a href="#第一个-Solidity-程序" class="headerlink" title="第一个 Solidity 程序"></a>第一个 Solidity 程序</h2><p>这个简单的程序只有 1 行注释和 3 行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract HelloWeb3&#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拆解程序，学习 Solidity 代码源文件的结构：</p><ol><li><p>第 1 行是注释，说明代码所使用的软件许可（license），这里使用的是 MIT 许可。如果不写许可，编译时会出现警告（warning），但程序仍可运行。Solidity 注释以“&#x2F;&#x2F;”开头，后面跟注释内容，注释不会被程序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br></pre></td></tr></table></figure></li><li><p>第 2 行声明源文件所使用的 Solidity 版本，因为不同版本的语法有差异。这行代码表示源文件将不允许小于 0.8.21 版本或大于等于 0.9.0 的编译器编译（第二个条件由 <code>^</code> 提供）。Solidity 语句以分号（;）结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.21;</span><br></pre></td></tr></table></figure></li><li><p>第 3-4 行是合约部分。第 3 行创建合约（contract），并声明合约名为 <code>HelloWeb3</code>。第 4 行是合约内容，声明了一个 string（字符串）变量 <code>_string</code>，并赋值为 “Hello Web3!”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWeb3 &#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>后续我们会更详细地介绍 Solidity 中的变量。</p><h2 id="编译并部署代码"><a href="#编译并部署代码" class="headerlink" title="编译并部署代码"></a>编译并部署代码</h2><p>在 Remix 编辑代码的页面，按 Ctrl + S 即可编译代码，非常方便。</p><p>编译完成后，点击左侧菜单的“部署”按钮，进入部署页面。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/01_HelloWeb3/img/1-2.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/1-2.png" alt="Deploy配图"></a></p><p>默认情况下，<code>Remix</code> 会使用 <code>Remix</code> 虚拟机（以前称为 JavaScript 虚拟机）来模拟以太坊链，运行智能合约，类似在浏览器里运行一条测试链。<code>Remix</code> 还会为你分配一些测试账户，每个账户里有 100 ETH（测试代币），随意使用。点击 <code>Deploy</code>（黄色按钮），即可部署我们编写的合约。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/01_HelloWeb3/img/1-3.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/1-3.png" alt="_string配图"></a></p><p>部署成功后，在下方会看到名为 <code>HelloWeb3</code> 的合约。点击 <code>_string</code>，即可看到 “Hello Web3!”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节课程中，我们简要介绍了 <code>Solidity</code> 和 <code>Remix</code> 工具，并完成了第一个 <code>Solidity</code> 程序 —— <code>HelloWeb3</code>。接下来，我们将继续深入学习 <code>Solidity</code>！</p><h3 id="中文-Solidity-资料推荐"><a href="#中文-Solidity-资料推荐" class="headerlink" title="中文 Solidity 资料推荐"></a>中文 Solidity 资料推荐</h3><ol><li><a href="https://docs.soliditylang.org/zh/v0.8.19/index.html">Solidity中文文档</a>（官方文档的中文翻译）</li><li><a href="https://space.bilibili.com/286084162">崔棉大师solidity教程</a> web3技术教学博主，我看他视频学到了很多</li></ol><h1 id="WTF-Solidity极简入门-2-值类型"><a href="#WTF-Solidity极简入门-2-值类型" class="headerlink" title="WTF Solidity极简入门: 2. 值类型"></a>WTF Solidity极简入门: 2. 值类型</h1><h2 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h2><p>&#x3D;&#x3D;主要就是这3种类型&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>引用类型(Reference Type)<strong>：包括</strong>数组</strong>和<strong>结构体</strong>，这类变量占空间大，赋值时候<strong>直接传递地址</strong>（类似指针）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>映射类型(Mapping Type)</strong>: Solidity中存储<strong>键值对</strong>的数据结构，可以理解为哈希表&#x3D;&#x3D;</li><li>函数类型(Function Types) : 代表函数的变量</li></ol><p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 布尔值</span><br><span class="line">bool public _bool = true;</span><br></pre></td></tr></table></figure><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 布尔运算</span><br><span class="line">bool public _bool1 = !_bool; // 取非</span><br><span class="line">bool public _bool2 = _bool &amp;&amp; _bool1; // 与</span><br><span class="line">bool public _bool3 = _bool || _bool1; // 或</span><br><span class="line">bool public _bool4 = _bool == _bool1; // 相等</span><br><span class="line">bool public _bool5 = _bool != _bool1; // 不相等</span><br></pre></td></tr></table></figure><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 整型</span><br><span class="line">int public _int = -1; // 整数，包括负数</span><br><span class="line">uint public _uint = 1; // 正整数</span><br><span class="line">uint256 public _number = 20220330; // 256位正整数</span><br></pre></td></tr></table></figure><p>常用的整型运算符包括：</p><ul><li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li><li>算数运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 整数运算</span><br><span class="line">uint256 public _number1 = _number + 1; // +，-，*，/</span><br><span class="line">uint256 public _number2 = 2**2; // 指数</span><br><span class="line">uint256 public _number3 = 7 % 2; // 取余数</span><br><span class="line">bool public _numberbool = _number2 &gt; _number3; // 比大小</span><br></pre></td></tr></table></figure><p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p><h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型(address)有两类：</p><ul><li>&#x3D;&#x3D;普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;payable address: 比普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员方法，用于接收转账。&#x3D;&#x3D;</li></ul><p>我们会在之后的章节更加详细地介绍 payable address。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 地址</span><br><span class="line">address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;</span><br><span class="line">address payable public _address1 = payable(_address); // payable address，可以转账、查余额</span><br><span class="line">// 地址类型的成员</span><br><span class="line">uint256 public balance = _address1.balance; // balance of address</span><br></pre></td></tr></table></figure><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>&#x3D;&#x3D;字节数组分为定长和不定长两种：&#x3D;&#x3D;</p><ul><li>&#x3D;&#x3D;定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组<strong>最多存储 32 bytes</strong> 数据，即<code>bytes32</code>。&#x3D;&#x3D;</li><li>不定长字节数组: 属于&#x3D;&#x3D;引用类型&#x3D;&#x3D;（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度的字节数组</span><br><span class="line">bytes32 public _byte32 = &quot;MiniSolidity&quot;; </span><br><span class="line">bytes1 public _byte = _byte32[0]; </span><br></pre></td></tr></table></figure><p>在上述代码中，<code>MiniSolidity</code> 变量以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p><p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p><p>&#x3D;&#x3D;表示一个16进制需要4位，一个bytes1是8位，所以一个bytes1可以表示2个16进制位&#x3D;&#x3D;</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用enum将uint 0， 1， 2表示为Buy, Hold, Sell</span><br><span class="line">enum ActionSet &#123; Buy, Hold, Sell &#125;</span><br><span class="line">// 创建enum变量 action</span><br><span class="line">ActionSet action = ActionSet.Buy;</span><br></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的正整数是否在枚举的长度内，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// enum可以和uint显式的转换</span><br><span class="line">function enumToUint() external view returns(uint)&#123;</span><br><span class="line">    return uint(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enum</code> 是一个比较冷门的变量，几乎没什么人用。</p><h2 id="在-Remix-上运行"><a href="#在-Remix-上运行" class="headerlink" title="在 Remix 上运行"></a>在 Remix 上运行</h2><ul><li>部署合约后可以查看每个类型的变量的数值：</li></ul><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/02_ValueTypes/img/2-1.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/2-1.png" alt="2-1.png"></a></p><ul><li><code>enum</code> 和 <code>uint</code> 转换的示例：</li></ul><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/02_ValueTypes/img/2-2.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/2-2.png" alt="2-2.png"></a> <a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/02_ValueTypes/img/2-3.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/2-3.png" alt="2-3.png"></a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 Solidity 中值类型，包括布尔型、整型、地址、定长字节数组和枚举。在后续章节，我们将继续介绍 Solidity 的其他变量类型，包括引用类型和映射类型。</p><h1 id="Solidity极简入门-3-函数类型"><a href="#Solidity极简入门-3-函数类型" class="headerlink" title="Solidity极简入门: 3. 函数类型"></a>Solidity极简入门: 3. 函数类型</h1><p>solidity官方文档里把函数归到数值类型，但我觉得差别很大，所以单独分一类。我们先看一下solidity中函数的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function &lt;function name&gt;(&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><p>Copy</p><p>看着些复杂，咱们从前往后一个一个看（方括号中的是可写可不写的关键字）：</p><ol><li><p><code>function</code>：声明函数时的固定用法，想写函数，就要以function关键字开头。</p></li><li><p><code>&lt;function name&gt;</code>：函数名。</p></li><li><p><code>(&lt;parameter types&gt;)</code>：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。</p></li><li><p><code>&#123;internal|external|public|private&#125;</code>：&#x3D;&#x3D;函数可见性说明符&#x3D;&#x3D;，一共4种。没标明函数类型的，&#x3D;&#x3D;默认&#x3D;&#x3D;<code>public</code>。合约之外的函数，即”自由函数”，始终具有隐含<code>internal</code>可见性。</p><ul><li><code>public</code>: 内部外部均可见。</li><li><code>private</code>: 只能从本合约内部访问，继承的合约也不能用。</li><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 &#x3D;&#x3D;这里this后文有解释&#x3D;&#x3D;</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><p><strong>Note 1</strong>: 没有标明可见性类型的函数，默认为<code>public</code>。</p><p><strong>Note 2</strong>: <code>public|private|internal</code> 也可用于&#x3D;&#x3D;修饰状态变量&#x3D;&#x3D;。 &#x3D;&#x3D;<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。&#x3D;&#x3D;</p><p><strong>Note 3</strong>: 没有标明可见性类型的&#x3D;&#x3D;状态变量，默认为<code>internal</code>。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;注意这里状态变量和函数可见性的不一样，默认为只能从合约内部访问&#x3D;&#x3D;</p></li><li><p><code>[pure|view|payable]</code>：&#x3D;&#x3D;决定函数权限&#x2F;功能的关键字&#x3D;&#x3D;。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入<code>ETH</code>。<code>pure</code>和<code>view</code>的介绍见下一节。</p></li></ol><p>&#x3D;&#x3D;如果没有写这三个关键字就是可读可写&#x3D;&#x3D;</p><ol><li><code>[returns ()]</code>：函数返回的变量类型和名称。</li></ol><h2 id="到底什么是Pure和View"><a href="#到底什么是Pure和View" class="headerlink" title="到底什么是Pure和View"></a>到底什么是<code>Pure</code>和<code>View</code></h2><p>我刚开始学<code>solidity</code>的时候，一直不理解<code>pure</code>跟<code>view</code>关键字，因为别的语言没有类似的关键字。<code>solidity</code>加入这两个关键字，我认为是因为<code>gas fee</code>。合约的状态变量存储在链上，<code>gas fee</code>很贵，如果不改变链上状态，就不用付<code>gas</code>。包含<code>pure</code>跟<code>view</code>关键字的函数是&#x3D;&#x3D;<strong>不改写链上状态的</strong>&#x3D;&#x3D;，因此用户直接调用他们是不需要付gas的（合约中非<code>pure</code>&#x2F;<code>view</code>函数调用它们则会改写链上状态，需要付gas）。</p><p>&#x3D;&#x3D;这里可太重要了&#x3D;&#x3D;</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用<code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记<code>view</code>或<code>pure</code>的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><p>我画了一个马里奥插画，帮助大家理解。在插画里，我把合约中的状态变量（存储在链上）比作碧池公主，三种不同的角色代表不同的关键字。</p><p><a href="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538"><img src="https://camo.githubusercontent.com/31d0d999b265f7576672cd60c4c7cefdfd80c2de1630a4d96c78c7c423ad1ce9/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f3142396b487354596e44595f51555253574d6d50622e706e673f6865696768743d313032382677696474683d31373538" alt="WTF is pure and view in solidity?"></a></p><ul><li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数<strong>既不能读取也不能写入链上的状态变量</strong>。就像小怪一样，看不到也摸不到碧琪公主。</li><li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li><li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-pure-和-view"><a href="#1-pure-和-view" class="headerlink" title="1. pure 和 view"></a>1. pure 和 view</h3><p>我们在合约里定义一个状态变量 <code>number</code>，初始化为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract FunctionTypes&#123;</span><br><span class="line">    uint256 public number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>add()</code> 函数，每次调用会让 <code>number</code> 增加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 默认function</span><br><span class="line">function add() external&#123;</span><br><span class="line">    number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>add()</code> 函数被标记为 <code>pure</code>，比如 <code>function add() external pure</code>，就会报错。因为 <code>pure</code> 是不配读取合约里的状态变量的，更不配改写。那 <code>pure</code> 函数能做些什么？举个例子，你可以给函数传递一个参数 <code>_number</code>，然后让他返回 <code>_number + 1</code>，这个操作不会读取或写入状态变量。</p><p>&#x3D;&#x3D;我的理解就是，参数或者函数内部定义的变量都不是状态变量，函数结束了，这些变量就消失了，也不上链&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pure: 纯纯牛马</span><br><span class="line">function addPure(uint256 _number) external pure returns(uint256 new_number)&#123;</span><br><span class="line">    new_number = _number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-3.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/3-3.png" alt="3-3.png"></a></p><p>如果 <code>add()</code> 函数被标记为 <code>view</code>，比如 <code>function add() external view</code>，也会报错。因为 <code>view</code> 能读取，但不能够改写状态变量。我们可以稍微改写下函数，读取但是不改写 <code>number</code>，返回一个新的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// view: 看客</span><br><span class="line">function addView() external view returns(uint256 new_number) &#123;</span><br><span class="line">    new_number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-4.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/3-4.png" alt="3-4.png"></a></p><p>&#x3D;&#x3D;重点来了，view和pure的区别就是view可以读取状态变量，pure不可以读取状态变量，他的输出只能由参数决定。&#x3D;&#x3D;</p><h3 id="2-internal-v-s-external"><a href="#2-internal-v-s-external" class="headerlink" title="2. internal v.s. external"></a>2. internal v.s. external</h3><ul><li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// internal: 内部函数</span><br><span class="line">function minus() internal &#123;</span><br><span class="line">    number = number - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约内的函数可以调用内部函数</span><br><span class="line">function minusCall() external &#123;</span><br><span class="line">    minus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;重点来了，也就是带有函数可见性说明符internal的，在部署完之后，不可以调用，因为我们部署完合约之后，在remix里面进行函数调用，查看变量，传参都相当于在合约外部调用，所以想要调用带有internal的函数，只能通过另外一个external函数调用&#x3D;&#x3D;</p><p>我们定义一个 <code>internal</code> 的 <code>minus()</code> 函数，每次调用使得 <code>number</code> 变量减少 1。由于 <code>internal</code> 函数只能由合约内部调用，我们必须再定义一个 <code>external</code> 的 <code>minusCall()</code> 函数，通过它间接调用内部的 <code>minus()</code> 函数。</p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-1.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/3-1.png" alt="3-1.png"></a></p><h3 id="3-payable"><a href="#3-payable" class="headerlink" title="3. payable"></a>3. payable</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// payable: 递钱，能给合约支付eth的函数</span><br><span class="line">function minusPayable() external payable returns(uint256 balance) &#123;</span><br><span class="line">    minus();    </span><br><span class="line">    balance = address(this).balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>external payable</code> 的 <code>minusPayable()</code> 函数，间接的调用 <code>minus()</code>，并且返回合约里的 ETH 余额（<code>this</code> 关键字可以让我们引用合约地址）。我们可以在调用 <code>minusPayable()</code> 时往合约里转入1个 ETH。</p><p>&#x3D;&#x3D;<code>this</code>关键字代表合约自身的地址。<code>address(this).balance</code>会返回当前合约地址所持有的以太币（ETH）数量，以wei为单位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>关键字代表当前合约的实例。它允许你在合约内部访问合约自身的成员，比如函数和状态变量。<code>this</code>可以在合约的任何函数内使用，但通常在需要引用合约自身的上下文中使用，比如转账操作时指向合约自己的地址（<code>address(this)</code>）。这使得合约能够操作自己的属性和调用自己的方法。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在Solidity中，<code>this</code>除了用于引用合约自身的实例和获取合约的地址外（<code>address(this)</code>），还可以用来在合约内部调用当前合约的其他公共和外部函数。例如，如果你有一个公共函数<code>functionA</code>，你可以通过<code>this.functionA()</code>来调用它，尤其在需要显式地表明函数调用是在合约内部发生时。这种方式通常用于需要通过合约地址调用函数的场景，确保调用遵循EVM的调用规则，如通过消息调用（message call）。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;一言以蔽之：在合约内部使用<code>this</code>调用函数，实际上是模拟外部调用者的行为。&#x3D;&#x3D;</p><p><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    uint256 public myNumber;</span><br><span class="line"></span><br><span class="line">    function setMyNumber(uint256 _myNumber) external &#123;</span><br><span class="line">        myNumber = _myNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateMyNumber(uint256 _newNumber) public &#123;</span><br><span class="line">        // 使用this关键字调用当前合约的另一个函数(external) 必须使用this</span><br><span class="line">        this.setMyNumber(_newNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838"><img src="https://camo.githubusercontent.com/3510ffb976a1b6b103538c63a24d4b609824e20757ed658ae1f1a04c0f2b526b/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f455444504e386d7971376a4666414c3843554146742e706e673f6865696768743d3134382677696474683d353838" alt="mirror-image-1"></a></p><p>我们可以在返回的信息中看到，合约的余额变为 1 ETH。</p><p><a href="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330"><img src="https://camo.githubusercontent.com/eba1591e2f664927a48814e341b6b804f69225071ed76707ec29e46975d2ca49/68747470733a2f2f696d616765732e6d6972726f722d6d656469612e78797a2f7075626c69636174696f6e2d696d616765732f6e475a32707a304d767a6758754b72454e4a5059662e706e673f6865696768743d3132382677696474683d31313330" alt="mirror-image-2"></a></p><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/img/3-2.png"><img src="/../../source/images/solidity%E5%9F%BA%E7%A1%801/3-2.png" alt="3-2.png"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们介绍了 <code>Solidity</code> 中的函数。<code>pure</code> 和 <code>view</code> 关键字比较难理解，在其他语言中没出现过：<code>view</code> 函数可以读取状态变量，但不能改写；<code>pure</code> 函数既不能读取也不能改写状态变量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/13/hello-world/"/>
      <url>/2024/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
